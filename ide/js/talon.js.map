{"version":3,"sources":["D:\\Source\\Talon2\\Talon\\out\\talon\\PaneOutput.js","D:\\Source\\Talon2\\Talon\\out\\talon\\TalonIde.js","D:\\Source\\Talon2\\Talon\\out\\talon\\common\\EventType.js","D:\\Source\\Talon2\\Talon\\out\\talon\\common\\Field.js","D:\\Source\\Talon2\\Talon\\out\\talon\\common\\Instruction.js","D:\\Source\\Talon2\\Talon\\out\\talon\\common\\Method.js","D:\\Source\\Talon2\\Talon\\out\\talon\\common\\OpCode.js","D:\\Source\\Talon2\\Talon\\out\\talon\\common\\Parameter.js","D:\\Source\\Talon2\\Talon\\out\\talon\\common\\Type.js","D:\\Source\\Talon2\\Talon\\out\\talon\\common\\Version.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\TalonCompiler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\exceptions\\CompilationError.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\lexing\\Keywords.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\lexing\\Punctuation.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\lexing\\TalonLexer.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\lexing\\Token.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\lexing\\TokenType.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\ParseContext.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\TalonParser.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\ActionsExpression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\BinaryExpression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\ComparisonExpression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\ConcatenationExpression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\ContainsExpression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\Expression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\FieldDeclarationExpression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\IdentifierExpression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\IfExpression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\ListExpression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\LiteralExpression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\ProgramExpression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\SayExpression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\SetVariableExpression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\TypeDeclarationExpression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\UnderstandingDeclarationExpression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\expressions\\WhenDeclarationExpression.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\visitors\\BlockExpressionVisitor.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\visitors\\ComparisonExpressionVisitor.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\visitors\\EventExpressionVisitor.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\visitors\\ExpressionVisitor.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\visitors\\FieldDeclarationVisitor.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\visitors\\IfExpressionVisitor.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\visitors\\ProgramVisitor.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\visitors\\SayExpressionVisitor.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\visitors\\TypeDeclarationVisitor.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\visitors\\UnderstandingDeclarationVisitor.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\visitors\\Visitor.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\parsing\\visitors\\WhenDeclarationVisitor.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\semantics\\TalonSemanticAnalyzer.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\transforming\\ExpressionTransformationMode.js","D:\\Source\\Talon2\\Talon\\out\\talon\\compiler\\transforming\\TalonTransformer.js","D:\\Source\\Talon2\\Talon\\out\\talon\\ide\\AnalysisCoordinator.js","D:\\Source\\Talon2\\Talon\\out\\talon\\ide\\CaretPosition.js","D:\\Source\\Talon2\\Talon\\out\\talon\\ide\\analyzers\\CodePaneAnalyzer.js","D:\\Source\\Talon2\\Talon\\out\\talon\\ide\\formatters\\CodePaneStyleFormatter.js","D:\\Source\\Talon2\\Talon\\out\\talon\\library\\Any.js","D:\\Source\\Talon2\\Talon\\out\\talon\\library\\BooleanType.js","D:\\Source\\Talon2\\Talon\\out\\talon\\library\\Convert.js","D:\\Source\\Talon2\\Talon\\out\\talon\\library\\Decoration.js","D:\\Source\\Talon2\\Talon\\out\\talon\\library\\Delegate.js","D:\\Source\\Talon2\\Talon\\out\\talon\\library\\EntryPointAttribute.js","D:\\Source\\Talon2\\Talon\\out\\talon\\library\\ExternCall.js","D:\\Source\\Talon2\\Talon\\out\\talon\\library\\Item.js","D:\\Source\\Talon2\\Talon\\out\\talon\\library\\List.js","D:\\Source\\Talon2\\Talon\\out\\talon\\library\\NumberType.js","D:\\Source\\Talon2\\Talon\\out\\talon\\library\\Place.js","D:\\Source\\Talon2\\Talon\\out\\talon\\library\\Player.js","D:\\Source\\Talon2\\Talon\\out\\talon\\library\\Say.js","D:\\Source\\Talon2\\Talon\\out\\talon\\library\\StringType.js","D:\\Source\\Talon2\\Talon\\out\\talon\\library\\Understanding.js","D:\\Source\\Talon2\\Talon\\out\\talon\\library\\WorldObject.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\EvaluationResult.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\MethodActivation.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\OpCodeHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\RuntimeState.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\StackFrame.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\TalonRuntime.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\Thread.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\common\\Memory.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\common\\State.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\common\\StateMachine.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\errors\\RuntimeError.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\AddHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\AssignVariableHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\BranchRelativeHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\BranchRelativeIfFalseHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\CompareLessThanHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\ComparisonHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\ConcatenateHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\CreateDelegateHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\ExternalCallHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\GoToHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\HandleCommandHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\InstanceCallHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\InvokeDelegateHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\InvokeDelegateOnInstanceHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\LoadBooleanHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\LoadElementHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\LoadEmptyHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\LoadFieldHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\LoadInstanceHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\LoadLocalHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\LoadNumberHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\LoadPropertyHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\LoadStringHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\LoadThisHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\NewInstanceHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\NoOpHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\ParseCommandHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\PrintHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\ReadInputHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\ReturnHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\SetLocalHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\StaticCallHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\handlers\\TypeOfHandler.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\library\\Meaning.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\library\\RuntimeAny.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\library\\RuntimeBoolean.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\library\\RuntimeCommand.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\library\\RuntimeDecoration.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\library\\RuntimeDelegate.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\library\\RuntimeEmpty.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\library\\RuntimeInteger.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\library\\RuntimeItem.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\library\\RuntimeList.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\library\\RuntimePlace.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\library\\RuntimePlayer.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\library\\RuntimeSay.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\library\\RuntimeString.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\library\\RuntimeWorldObject.js","D:\\Source\\Talon2\\Talon\\out\\talon\\runtime\\library\\Variable.js","webpack/bootstrap","D:\\Source\\Talon2\\Talon\\out\\talon\\main.js"],"names":[],"mappings":";;;;;;;;;;AAAa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yD;;;;;;;;;;ACzBa;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB;AAChB,wBAAwB,mBAAO,CAAC,uEAA0B;AAC1D,qBAAqB,mBAAO,CAAC,+CAAc;AAC3C,uBAAuB,mBAAO,CAAC,mEAAwB;AACvD,8BAA8B,mBAAO,CAAC,yEAA2B;AACjE,2BAA2B,mBAAO,CAAC,uFAAkC;AACrE,iCAAiC,mBAAO,CAAC,qGAAyC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG,yDAAyD,EAAE;AAClK,uGAAuG,mCAAmC,EAAE;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,iCAAiC;AACnH;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA,+DAA+D;AAC/D,uCAAuC;AACvC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G;AAC3G,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,uD;;;;;;;;;;AC3Ja;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC,iBAAiB,KAAK;AAC3D,kE;;;;;;;;;;ACTa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,8D;;;;;;;;;;ACVa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,mBAAmB;AACnB,iBAAiB,mBAAO,CAAC,8CAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,SAAS,GAAG,WAAW;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,SAAS,GAAG,WAAW;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,oE;;;;;;;;;;ACjHa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc;AACd,oBAAoB,mBAAO,CAAC,oDAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,+D;;;;;;;;;;ACfa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B,cAAc,KAAK;AAClD,+D;;;;;;;;;;ACvCa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,kE;;;;;;;;;;ACVa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,6D;;;;;;;;;;ACnBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW,GAAG,WAAW,GAAG,WAAW;AACzD;AACA;AACA,eAAe;AACf,gE;;;;;;;;;;ACda;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,qBAAqB;AACrB,eAAe,mBAAO,CAAC,kDAAgB;AACvC,iBAAiB,mBAAO,CAAC,sDAAkB;AAC3C,cAAc,mBAAO,CAAC,kDAAgB;AACtC,sBAAsB,mBAAO,CAAC,gEAAuB;AACrD,8BAA8B,mBAAO,CAAC,kFAAgC;AACtE,qBAAqB,mBAAO,CAAC,sEAAqB;AAClD,sBAAsB,mBAAO,CAAC,0EAAuB;AACrD,gCAAgC,mBAAO,CAAC,kGAAmC;AAC3E,2BAA2B,mBAAO,CAAC,8FAAiC;AACpE,kBAAkB,mBAAO,CAAC,wDAAmB;AAC7C,2BAA2B,mBAAO,CAAC,0FAA+B;AAClE,mBAAmB,mBAAO,CAAC,4DAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA,uDAAuD,GAAG;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,qBAAqB,eAAe,aAAa;AACjI;AACA;AACA;AACA;AACA,qBAAqB;AACrB,wE;;;;;;;;;;AChEa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,yF;;;;;;;;;;ACTa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6E;;;;;;;;;;ACjEa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB;AACA;AACA,0BAA0B;AAC1B;AACA,gF;;;;;;;;;;ACVa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,kBAAkB;AAClB,gBAAgB,mBAAO,CAAC,qDAAS;AACjC,mBAAmB,mBAAO,CAAC,2DAAY;AACvC,sBAAsB,mBAAO,CAAC,iEAAe;AAC7C,oBAAoB,mBAAO,CAAC,6DAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8BAA8B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,+E;;;;;;;;;;AC5Ga;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,aAAa;AACb,oBAAoB,mBAAO,CAAC,6DAAa;AACzC,gBAAgB,mBAAO,CAAC,yDAAqB;AAC7C,cAAc,mBAAO,CAAC,qDAAmB;AACzC,sBAAsB,mBAAO,CAAC,qEAA2B;AACzD,sBAAsB,mBAAO,CAAC,qEAA2B;AACzD,eAAe,mBAAO,CAAC,uDAAoB;AAC3C,eAAe,mBAAO,CAAC,uDAAoB;AAC3C,qBAAqB,mBAAO,CAAC,mEAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,IAAI,YAAY,iBAAiB,WAAW,aAAa,UAAU;AAC/F;AACA;AACA,aAAa;AACb,0E;;;;;;;;;;ACpDa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC,iBAAiB,KAAK;AAC3D,8E;;;;;;;;;;AChBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,oBAAoB;AACpB,gBAAgB,mBAAO,CAAC,6DAAiB;AACzC,2BAA2B,mBAAO,CAAC,2FAAgC;AACnE,oBAAoB,mBAAO,CAAC,qEAAqB;AACjD;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,WAAW;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,QAAQ,IAAI,kBAAkB;AACxF;AACA;AACA,oBAAoB;AACpB,kF;;;;;;;;;;ACvGa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,mBAAmB;AACnB,yBAAyB,mBAAO,CAAC,0FAA2B;AAC5D,uBAAuB,mBAAO,CAAC,oEAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,iF;;;;;;;;;;AChBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,yBAAyB;AACzB,qBAAqB,mBAAO,CAAC,4EAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,sG;;;;;;;;;;ACXa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,wBAAwB;AACxB,qBAAqB,mBAAO,CAAC,4EAAc;AAC3C;AACA;AACA,wBAAwB;AACxB,qG;;;;;;;;;;ACPa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,4BAA4B;AAC5B,2BAA2B,mBAAO,CAAC,wFAAoB;AACvD;AACA;AACA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CA;AACA,yBAAyB;AACzB,mG;;;;;;;;;;AClFa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,+BAA+B;AAC/B,kBAAkB,mBAAO,CAAC,mEAAW;AACrC,mBAAmB,mBAAO,CAAC,sEAAuB;AAClD,qCAAqC,mBAAO,CAAC,yHAA2C;AACxF,gBAAgB,mBAAO,CAAC,4DAAwB;AAChD,sBAAsB,mBAAO,CAAC,wEAA8B;AAC5D,2BAA2B,mBAAO,CAAC,8FAAmC;AACtE,sBAAsB,mBAAO,CAAC,wEAA8B;AAC5D,qBAAqB,mBAAO,CAAC,sEAA6B;AAC1D,eAAe,mBAAO,CAAC,0DAAuB;AAC9C,4BAA4B,mBAAO,CAAC,uFAAqB;AACzD,kCAAkC,mBAAO,CAAC,mHAAwC;AAClF,oBAAoB,mBAAO,CAAC,wEAAwB;AACpD,qBAAqB,mBAAO,CAAC,sEAA6B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,2BAA2B,aAAa,0BAA0B;AACpL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,yG;;;;;;;;;;ACnIa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,2BAA2B;AAC3B,kBAAkB,mBAAO,CAAC,mEAAW;AACrC,mBAAmB,mBAAO,CAAC,sEAAuB;AAClD,4BAA4B,mBAAO,CAAC,uFAAqB;AACzD,uBAAuB,mBAAO,CAAC,6FAA6B;AAC5D,iCAAiC,mBAAO,CAAC,iGAA0B;AACnE,2BAA2B,mBAAO,CAAC,8FAAmC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH,qBAAqB;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,qG;;;;;;;;;;ACvCa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,sBAAsB;AACtB,kBAAkB,mBAAO,CAAC,mEAAW;AACrC,mBAAmB,mBAAO,CAAC,sEAAuB;AAClD,iCAAiC,mBAAO,CAAC,iGAA0B;AACnE,4BAA4B,mBAAO,CAAC,uGAAkC;AACtE,2BAA2B,mBAAO,CAAC,8FAAmC;AACtE,0CAA0C,mBAAO,CAAC,mHAAmC;AACrF,+BAA+B,mBAAO,CAAC,6FAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,qBAAqB;AAC9G;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,gG;;;;;;;;;;ACxCa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,4BAA4B;AAC5B,kBAAkB,mBAAO,CAAC,mEAAW;AACrC,mBAAmB,mBAAO,CAAC,sEAAuB;AAClD,wBAAwB,mBAAO,CAAC,+FAA8B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,sG;;;;;;;;;;ACda;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,8BAA8B;AAC9B,kBAAkB,mBAAO,CAAC,mEAAW;AACrC,mBAAmB,mBAAO,CAAC,sEAAuB;AAClD,oCAAoC,mBAAO,CAAC,uHAA0C;AACtF,kCAAkC,mBAAO,CAAC,mGAA2B;AACrE,iCAAiC,mBAAO,CAAC,iGAA0B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,wG;;;;;;;;;;AC7Ca;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,uCAAuC;AACvC,kBAAkB,mBAAO,CAAC,mEAAW;AACrC,mBAAmB,mBAAO,CAAC,sEAAuB;AAClD,6CAA6C,mBAAO,CAAC,yIAAmD;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,iH;;;;;;;;;;ACjBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,eAAe;AACf;AACA;AACA,eAAe;AACf,yF;;;;;;;;;;ACNa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,8BAA8B;AAC9B,kBAAkB,mBAAO,CAAC,mEAAW;AACrC,mBAAmB,mBAAO,CAAC,sEAAuB;AAClD,oCAAoC,mBAAO,CAAC,uHAA0C;AACtF,iCAAiC,mBAAO,CAAC,iGAA0B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,wG;;;;;;;;;;ACpBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,6BAA6B;AAC7B,4BAA4B,mBAAO,CAAC,+GAA0C;AAC9E,oCAAoC,mBAAO,CAAC,+HAAkD;AAC9F,gBAAgB,mBAAO,CAAC,6DAAiB;AACzC,oBAAoB,mBAAO,CAAC,qEAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,6F;;;;;;;;;;AC7Ca;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,oCAAoC;AACpC;AACA;AACA;AACA;AACA,CAAC,0EAA0E,oCAAoC,KAAK;AACpH,uG;;;;;;;;;;ACRa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,wBAAwB;AACxB,eAAe,mBAAO,CAAC,qDAAmB;AAC1C,4BAA4B,mBAAO,CAAC,+GAA0C;AAC9E,2BAA2B,mBAAO,CAAC,2FAAgC;AACnE,oCAAoC,mBAAO,CAAC,+HAAkD;AAC9F,6CAA6C,mBAAO,CAAC,iJAA2D;AAChH,wBAAwB,mBAAO,CAAC,yEAA6B;AAC7D,gBAAgB,mBAAO,CAAC,uDAAoB;AAC5C,cAAc,mBAAO,CAAC,qDAAmB;AACzC,sBAAsB,mBAAO,CAAC,qEAA2B;AACzD,gBAAgB,mBAAO,CAAC,yDAAqB;AAC7C,sBAAsB,mBAAO,CAAC,qEAA2B;AACzD,qBAAqB,mBAAO,CAAC,mEAA0B;AACvD,eAAe,mBAAO,CAAC,uDAAoB;AAC3C,qBAAqB,mBAAO,CAAC,mEAA0B;AACvD,eAAe,mBAAO,CAAC,uDAAoB;AAC3C,iBAAiB,mBAAO,CAAC,2DAAsB;AAC/C,wBAAwB,mBAAO,CAAC,uGAAsC;AACtE,iBAAiB,mBAAO,CAAC,yDAAqB;AAC9C,cAAc,mBAAO,CAAC,qDAAmB;AACzC,sBAAsB,mBAAO,CAAC,mEAA0B;AACxD,oBAAoB,mBAAO,CAAC,+DAAwB;AACpD,uBAAuB,mBAAO,CAAC,qGAAqC;AACpE,kCAAkC,mBAAO,CAAC,2HAAgD;AAC1F,6BAA6B,mBAAO,CAAC,iHAA2C;AAChF,qCAAqC,mBAAO,CAAC,iIAAmD;AAChG,4BAA4B,mBAAO,CAAC,+GAA0C;AAC9E,mBAAmB,mBAAO,CAAC,mEAAoB;AAC/C,oBAAoB,mBAAO,CAAC,+DAAwB;AACpD,uCAAuC,mBAAO,CAAC,yGAAgC;AAC/E,gCAAgC,mBAAO,CAAC,uHAA8C;AACtF,4BAA4B,mBAAO,CAAC,+GAA0C;AAC9E,qBAAqB,mBAAO,CAAC,mEAA0B;AACvD,+BAA+B,mBAAO,CAAC,qHAA6C;AACpF,+BAA+B,mBAAO,CAAC,qHAA6C;AACpF,kBAAkB,mBAAO,CAAC,6DAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,uCAAuC,GAAG,iBAAiB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,YAAY,GAAG,gBAAgB,GAAG,oBAAoB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,KAAK;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH,WAAW;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,WAAW;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,2F;;;;;;;;;;ACnSa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa,WAAW,gBAAgB;AAClF;AACA;AACA;AACA,2BAA2B;AAC3B,yE;;;;;;;;;;ACpBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,mE;;;;;;;;;;ACVa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,wBAAwB;AACxB,wBAAwB,mBAAO,CAAC,0DAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,mF;;;;;;;;;;ACtCa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,0F;;;;;;;;;;AC3Ba;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,WAAW;AACX,qBAAqB,mBAAO,CAAC,uDAAc;AAC3C;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,6D;;;;;;;;;;ACXa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,mBAAm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,2BAA2B,mBAAO,CAAC,qFAA6B;AAChE,0BAA0B,mBAAO,CAAC,mFAA4B;AAC9D,gCAAgC,mBAAO,CAAC,+FAAkC;AAC1E,uCAAuC,mBAAO,CAAC,6GAAyC;AACxF,6BAA6B,mBAAO,CAAC,yFAA+B;AACpE,gCAAgC,mBAAO,CAAC,+FAAkC;AAC1E,wBAAwB,mBAAO,CAAC,+EAA0B;AAC1D,gCAAgC,mBAAO,CAAC,+FAAkC;AAC1E,4BAA4B,mBAAO,CAAC,uFAA8B;AAClE,uBAAuB,mBAAO,CAAC,2DAAgB;AAC/C,uBAAuB,mBAAO,CAAC,yEAAuB;AACtD,gBAAgB,mBAAO,CAAC,2DAAgB;AACxC,6BAA6B,mBAAO,CAAC,yFAA+B;AACpE,gCAAgC,mBAAO,CAAC,+FAAkC;AAC1E,iCAAiC,mBAAO,CAAC,iGAAmC;AAC5E,qBAAqB,mBAAO,CAAC,yEAAuB;AACpD,6BAA6B,mBAAO,CAAC,yFAA+B;AACpE,0BAA0B,mBAAO,CAAC,mFAA4B;AAC9D,2BAA2B,mBAAO,CAAC,qFAA6B;AAChE,0CAA0C,mBAAO,CAAC,mHAA4C;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ,6GAA6G;AAChK,0CAA0C,QAAQ,8FAA8F;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,6DAA6D;AAClI;AACA;AACA;AACA;AACA;AACA,sGAAsG,WAAW;AACjH,oGAAoG,SAAS;AAC7G;AACA;AACA,oHAAoH,GAAG;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,6EAA6E;AAClK;AACA;AACA;AACA;AACA,oBAAoB;AACpB,sE;;;;;;;;;;ACnMa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc;AACd,2BAA2B,mBAAO,CAAC,mEAAoB;AACvD,wBAAwB,mBAAO,CAAC,sEAA0B;AAC1D,uBAAuB,mBAAO,CAAC,2EAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,mEAAmE,MAAM,YAAY;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,8EAA8E,MAAM,0IAA0I;AACvS;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,gE;;;;;;;;;;ACxDa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc;AACd,gBAAgB,mBAAO,CAAC,yDAAqB;AAC7C,uBAAuB,mBAAO,CAAC,4EAAyB;AACxD,uBAAuB,mBAAO,CAAC,0EAAwB;AACvD,mBAAmB,mBAAO,CAAC,oEAAqB;AAChD,qBAAqB,mBAAO,CAAC,mEAA0B;AACvD,wBAAwB,mBAAO,CAAC,8EAA0B;AAC1D,uBAAuB,mBAAO,CAAC,4EAAyB;AACxD,yBAAyB,mBAAO,CAAC,gFAA2B;AAC5D,sBAAsB,mBAAO,CAAC,qEAA2B;AACzD,yBAAyB,mBAAO,CAAC,gFAA2B;AAC5D,eAAe,mBAAO,CAAC,uDAAoB;AAC3C,sBAAsB,mBAAO,CAAC,0EAAwB;AACtD,eAAe,mBAAO,CAAC,uDAAoB;AAC3C,sBAAsB,mBAAO,CAAC,0EAAwB;AACtD,iBAAiB,mBAAO,CAAC,2DAAsB;AAC/C,wBAAwB,mBAAO,CAAC,8EAA0B;AAC1D,cAAc,mBAAO,CAAC,qDAAmB;AACzC,qBAAqB,mBAAO,CAAC,wEAAuB;AACpD,yBAAyB,mBAAO,CAAC,gFAA2B;AAC5D,qBAAqB,mBAAO,CAAC,mEAA0B;AACvD,4BAA4B,mBAAO,CAAC,sFAA8B;AAClE,qBAAqB,mBAAO,CAAC,mEAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,KAAK;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,eAAe;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,SAAS;AAC9F;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,0E;;;;;;;;;;ACtKa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,yE;;;;;;;;;;AChBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,oBAAoB;AACpB,uBAAuB,mBAAO,CAAC,0EAAwB;AACvD,gBAAgB,mBAAO,CAAC,oDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,MAAM;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,gF;;;;;;;;;;AC9Ba;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,gF;;;;;;;;;;ACTa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,kBAAkB;AAClB,iBAAiB,mBAAO,CAAC,yDAAqB;AAC9C,iBAAiB,mBAAO,CAAC,8DAAkB;AAC3C,wBAAwB,mBAAO,CAAC,8DAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,gF;;;;;;;;;;ACrBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,6BAA6B;AAC7B,wBAAwB,mBAAO,CAAC,8DAAkB;AAClD,wBAAwB,mBAAO,CAAC,8EAA0B;AAC1D,uBAAuB,mBAAO,CAAC,0EAAwB;AACvD,yBAAyB,mBAAO,CAAC,gFAA2B;AAC5D,iBAAiB,mBAAO,CAAC,yDAAqB;AAC9C,yBAAyB,mBAAO,CAAC,gFAA2B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,2F;;;;;;;;;;AClCa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,6BAA6B;AAC7B,iBAAiB,mBAAO,CAAC,yDAAqB;AAC9C,wBAAwB,mBAAO,CAAC,8DAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,2F;;;;;;;;;;ACnBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,oCAAoC;AACpC,wBAAwB,mBAAO,CAAC,8DAAkB;AAClD,iBAAiB,mBAAO,CAAC,yDAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,kG;;;;;;;;;;ACtBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,8BAA8B;AAC9B,iBAAiB,mBAAO,CAAC,yDAAqB;AAC9C,iBAAiB,mBAAO,CAAC,8DAAkB;AAC3C,wBAAwB,mBAAO,CAAC,8DAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,4F;;;;;;;;;;ACrBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,yBAAyB;AACzB,iBAAiB,mBAAO,CAAC,yDAAqB;AAC9C,iBAAiB,mBAAO,CAAC,8DAAkB;AAC3C,uBAAuB,mBAAO,CAAC,0EAAwB;AACvD,yBAAyB,mBAAO,CAAC,gFAA2B;AAC5D,yBAAyB,mBAAO,CAAC,gFAA2B;AAC5D,wBAAwB,mBAAO,CAAC,8EAA0B;AAC1D,wBAAwB,mBAAO,CAAC,8DAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G,sEAAsE,MAAM,yEAAyE;AAChQ;AACA;AACA;AACA;AACA,yBAAyB;AACzB,uF;;;;;;;;;;ACtCa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,0BAA0B;AAC1B,wBAAwB,mBAAO,CAAC,8DAAkB;AAClD,iBAAiB,mBAAO,CAAC,8DAAkB;AAC3C,iBAAiB,mBAAO,CAAC,yDAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,wF;;;;;;;;;;ACrBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,6BAA6B;AAC7B,iBAAiB,mBAAO,CAAC,yDAAqB;AAC9C,iBAAiB,mBAAO,CAAC,8DAAkB;AAC3C,0BAA0B,mBAAO,CAAC,kFAA4B;AAC9D,mBAAmB,mBAAO,CAAC,oEAAqB;AAChD,wBAAwB,mBAAO,CAAC,8DAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,2F;;;;;;;;;;AC7Ba;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,2BAA2B;AAC3B,wBAAwB,mBAAO,CAAC,8DAAkB;AAClD,iBAAiB,mBAAO,CAAC,yDAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sEAAsE,IAAI,WAAW,MAAM,cAAc;AAChJ;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,yF;;;;;;;;;;AC/Ba;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,mBAAmB;AACnB,wBAAwB,mBAAO,CAAC,8DAAkB;AAClD,uBAAuB,mBAAO,CAAC,0EAAwB;AACvD,iBAAiB,mBAAO,CAAC,yDAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,iF;;;;;;;;;;AC3Ba;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,4BAA4B;AAC5B,wBAAwB,mBAAO,CAAC,8DAAkB;AAClD,yBAAyB,mBAAO,CAAC,gFAA2B;AAC5D,uBAAuB,mBAAO,CAAC,0EAAwB;AACvD,wBAAwB,mBAAO,CAAC,yEAA6B;AAC7D,kBAAkB,mBAAO,CAAC,kEAAoB;AAC9C,6BAA6B,mBAAO,CAAC,wFAA+B;AACpE,sBAAsB,mBAAO,CAAC,qEAA2B;AACzD,iBAAiB,mBAAO,CAAC,8DAAkB;AAC3C,eAAe,mBAAO,CAAC,qDAAmB;AAC1C,iBAAiB,mBAAO,CAAC,2DAAsB;AAC/C,oBAAoB,mBAAO,CAAC,+DAAwB;AACpD,0BAA0B,mBAAO,CAAC,kFAA4B;AAC9D,mBAAmB,mBAAO,CAAC,oEAAqB;AAChD,sBAAsB,mBAAO,CAAC,0EAAwB;AACtD,iBAAiB,mBAAO,CAAC,yDAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,QAAQ;AACpG;AACA;AACA;AACA,wCAAwC,OAAO,GAAG,WAAW;AAC7D,oFAAoF,QAAQ,oJAAoJ,EAAE;AAClP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sHAAsH,WAAW;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,MAAM,GAAG,KAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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AC,uEAAkB;AACnD,iBAAiB,mBAAO,CAAC,8DAAkB;AAC3C,sBAAsB,mBAAO,CAAC,qEAA2B;AACzD,cAAc,mBAAO,CAAC,qDAAmB;AACzC,0BAA0B,mBAAO,CAAC,yEAAmB;AACrD,uBAAuB,mBAAO,CAAC,0EAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,gF;;;;;;;;;;AC3Fa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,oBAAoB;AACpB,6BAA6B,mBAAO,CAAC,+EAAsB;AAC3D,sBAAsB,mBAAO,CAAC,qEAA2B;AACzD,gBAAgB,mBAAO,CAAC,yDAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,iF;;;;;;;;;;ACnBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,qBAAqB;AACrB,6BAA6B,mBAAO,CAAC,+EAAsB;AAC3D,iBAAiB,mBAAO,CAAC,2DAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kF;;;;;;;;;;ACba;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,kBAAkB;AAClB,qBAAqB,mBAAO,CAAC,+DAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,+E;;;;;;;;;;ACXa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,qBAAqB;AACrB,qBAAqB,mBAAO,CAAC,+DAAc;AAC3C,cAAc,mBAAO,CAAC,qDAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA,qBAAqB;AACrB,kF;;;;;;;;;;ACjBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,0BAA0B;AAC1B,qBAAqB,mBAAO,CAAC,+DAAc;AAC3C,sBAAsB,mBAAO,CAAC,qEAA2B;AACzD,cAAc,mBAAO,CAAC,qDAAmB;AACzC,uBAAuB,mBAAO,CAAC,0EAAwB;AACvD,eAAe,mBAAO,CAAC,qDAAmB;AAC1C,gBAAgB,mBAAO,CAAC,uDAAoB;AAC5C,eAAe,mBAAO,CAAC,uDAAoB;AAC3C,qBAAqB,mBAAO,CAAC,mEAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,KAAK;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,uF;;;;;;;;;;AClDa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,6E;;;;;;UCfA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,mBAAmB,mBAAO,CAAC,2CAAY;AACvC;AACA,mD","file":"talon.js","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PaneOutput = void 0;\r\nclass PaneOutput {\r\n    constructor(pane) {\r\n        this.pane = pane;\r\n    }\r\n    clear() {\r\n        this.pane.innerHTML = \"\";\r\n    }\r\n    debug(line) {\r\n        if (line.startsWith('.')) {\r\n            const parts = line.split(' ');\r\n            parts[0] = `<strong>${parts[0]}</strong>`;\r\n            line = parts.join(' ');\r\n        }\r\n        this.pane.innerHTML += line + \"<br />\";\r\n        this.pane.scrollTo(0, this.pane.scrollHeight);\r\n    }\r\n    write(line) {\r\n        this.pane.innerHTML += line + \"<br />\";\r\n        this.pane.scrollTo(0, this.pane.scrollHeight);\r\n    }\r\n}\r\nexports.PaneOutput = PaneOutput;\r\n//# sourceMappingURL=../../ide/js/talon/PaneOutput.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TalonIde = void 0;\r\nconst TalonCompiler_1 = require(\"./compiler/TalonCompiler\");\r\nconst PaneOutput_1 = require(\"./PaneOutput\");\r\nconst TalonRuntime_1 = require(\"./runtime/TalonRuntime\");\r\nconst AnalysisCoordinator_1 = require(\"./ide/AnalysisCoordinator\");\r\nconst CodePaneAnalyzer_1 = require(\"./ide/analyzers/CodePaneAnalyzer\");\r\nconst CodePaneStyleFormatter_1 = require(\"./ide/formatters/CodePaneStyleFormatter\");\r\nclass TalonIde {\r\n    constructor() {\r\n        this.compiledTypes = [];\r\n        this.codePane = TalonIde.getById(\"code-pane\");\r\n        this.gamePane = TalonIde.getById(\"game-pane\");\r\n        this.compilationOutput = TalonIde.getById(\"compilation-output\");\r\n        this.gameLogOutput = TalonIde.getById(\"log-pane\");\r\n        this.openButton = TalonIde.getById(\"open\");\r\n        this.saveButton = TalonIde.getById(\"save\");\r\n        this.example1Button = TalonIde.getById(\"example1\");\r\n        this.compileButton = TalonIde.getById(\"compile\");\r\n        this.startNewGameButton = TalonIde.getById(\"start-new-game\");\r\n        this.userCommandText = TalonIde.getById(\"user-command-text\");\r\n        this.sendUserCommandButton = TalonIde.getById(\"send-user-command\");\r\n        this.caretPosition = TalonIde.getById(\"caret-position\");\r\n        this.saveButton.addEventListener('click', (e) => __awaiter(this, void 0, void 0, function* () { return yield this.saveCodeFile(this.codePane.innerText); }));\r\n        this.openButton.addEventListener('click', (e) => __awaiter(this, void 0, void 0, function* () { return yield this.openCodeFile(e); }));\r\n        this.example1Button.addEventListener('click', e => this.loadExample());\r\n        this.compileButton.addEventListener('click', e => this.compile());\r\n        this.startNewGameButton.addEventListener('click', e => this.startNewGame());\r\n        this.sendUserCommandButton.addEventListener('click', e => this.sendUserCommand());\r\n        this.userCommandText.addEventListener('keyup', e => {\r\n            if (e.key === \"Enter\") {\r\n                this.sendUserCommand();\r\n            }\r\n        });\r\n        this.userCommandText.value = \"look\";\r\n        this.compilationOutputPane = new PaneOutput_1.PaneOutput(this.compilationOutput);\r\n        this.runtimeOutputPane = new PaneOutput_1.PaneOutput(this.gamePane);\r\n        this.runtimeLogOutputPane = new PaneOutput_1.PaneOutput(this.gameLogOutput);\r\n        this.codePaneAnalyzer = new CodePaneAnalyzer_1.CodePaneAnalyzer(this.codePane);\r\n        this.analysisCoordinator = new AnalysisCoordinator_1.AnalysisCoordinator(this.codePaneAnalyzer, this.caretPosition);\r\n        this.codePaneStyleFormatter = new CodePaneStyleFormatter_1.CodePaneStyleFormatter(this.codePane);\r\n        this.compiler = new TalonCompiler_1.TalonCompiler(this.compilationOutputPane);\r\n        this.runtime = new TalonRuntime_1.TalonRuntime(this.runtimeOutputPane, this.runtimeLogOutputPane);\r\n    }\r\n    static getById(name) {\r\n        return document.getElementById(name);\r\n    }\r\n    sendUserCommand() {\r\n        const command = this.userCommandText.value;\r\n        this.runtime.sendCommand(command);\r\n        this.userCommandText.value = \"\";\r\n    }\r\n    compile() {\r\n        const code = this.codePane.innerText;\r\n        this.compilationOutputPane.clear();\r\n        this.compiledTypes = this.compiler.compile(code);\r\n    }\r\n    startNewGame() {\r\n        this.runtimeOutputPane.clear();\r\n        this.runtimeLogOutputPane.clear();\r\n        this.runtime.stop();\r\n        if (this.runtime.loadFrom(this.compiledTypes)) {\r\n            this.runtime.start();\r\n        }\r\n    }\r\n    openCodeFile(event) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const options = {\r\n                types: [\r\n                    {\r\n                        description: TalonIde.TalonCodeFileDescription,\r\n                        accept: {\r\n                            'text/plain': [TalonIde.TalonCodeFileExtension]\r\n                        }\r\n                    },\r\n                ],\r\n                excludeAcceptAllOption: true,\r\n                multiple: false\r\n            };\r\n            const handles = yield window.showOpenFilePicker(options);\r\n            const file = yield handles[0].getFile();\r\n            this.codePane.innerText = yield file.text();\r\n        });\r\n    }\r\n    saveCodeFile(contents) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const options = {\r\n                types: [\r\n                    {\r\n                        description: TalonIde.TalonCodeFileDescription,\r\n                        accept: {\r\n                            'text/plain': [TalonIde.TalonCodeFileExtension],\r\n                        },\r\n                    },\r\n                ],\r\n            };\r\n            const fileHandle = yield window.showSaveFilePicker(options);\r\n            const writable = yield fileHandle.createWritable();\r\n            yield writable.write(contents);\r\n            yield writable.close();\r\n        });\r\n    }\r\n    loadExample() {\r\n        this.codePane.innerText =\r\n            \"say \\\"This is the start.\\\".\\n\\n\" +\r\n                \"understand \\\"look\\\" as describing. \\n\" +\r\n                \"understand \\\"north\\\" as directions. \\n\" +\r\n                \"understand \\\"south\\\" as directions.\\n\" +\r\n                \"understand \\\"go\\\" as moving. \\n\" +\r\n                \"understand \\\"take\\\" as taking. \\n\" +\r\n                \"understand \\\"inv\\\" as inventory. \\n\" +\r\n                \"understand \\\"drop\\\" as dropping. \\n\\n\" +\r\n                \"an Inn is a kind of place. \\n\" +\r\n                \"it is where the player starts. \\n\" +\r\n                \"it is described as \\\"The inn is a cozy place, with a crackling fire on the hearth. The bartender is behind the bar. An open door to the north leads outside.\\\" \\n\" +\r\n                \"    and if it contains 1 Coin then \\\"There's also a coin here.\\\"; or else \\\"There is just dust.\\\"; and then continue.\\n\" +\r\n                \"it contains 1 Coin, 1 Fireplace.\\n\" +\r\n                \"it can reach the Walkway by going \\\"north\\\". \\n\" +\r\n                \"it has a value that is false. \\n\" +\r\n                \"when the player exits: \\n\" +\r\n                \"    if value is false then \\n\" +\r\n                \"        say \\\"The bartender waves goodbye.\\\"; \\n\" +\r\n                \"    or else \\n\" +\r\n                \"        say \\\"The bartender cleans the bar.\\\"; \\n\" +\r\n                \"    and then continue;\\n\" +\r\n                \"    set value to true; \\n\" +\r\n                \"and then stop. \\n\\n\" +\r\n                \"a Fireplace is a kind of decoration. \\n\" +\r\n                \"it is described as \\\"The fireplace crackles. It's full of fire.\\\". \\n\\n\" +\r\n                \"a Walkway is a kind of place. \\n\" +\r\n                \"it is described as \\\"The walkway in front of the inn is empty, just a cobblestone entrance. The inn is to the south.\\\". \\n\" +\r\n                \"it can reach the Inn by going \\\"south\\\". \\n\" +\r\n                \"when the player enters:\\n\" +\r\n                \"    say \\\"You walk onto the cobblestones. They're nice, if you like that sort of thing.\\\"; \\n\" +\r\n                \"    say \\\"There's nobody around. The wind whistles a little bit.\\\"; \\n\" +\r\n                \"and then stop. \\n\\n\" +\r\n                \"say \\\"This is the middle.\\\".\\n\\n\" +\r\n                \"a Coin is a kind of item. \\n\" +\r\n                \"it is described as \\\"It's a small coin.\\\".\\n\\n\" +\r\n                \"say \\\"This is the end.\\\".\\n\";\r\n    }\r\n}\r\nexports.TalonIde = TalonIde;\r\nTalonIde.TalonCodeFileDescription = \"Talon Code\";\r\nTalonIde.TalonCodeFileExtension = \".tln\";\r\n//# sourceMappingURL=../../ide/js/talon/TalonIde.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.EventType = void 0;\r\nvar EventType;\r\n(function (EventType) {\r\n    EventType[EventType[\"None\"] = 0] = \"None\";\r\n    EventType[EventType[\"PlayerEntersPlace\"] = 1] = \"PlayerEntersPlace\";\r\n    EventType[EventType[\"PlayerExitsPlace\"] = 2] = \"PlayerExitsPlace\";\r\n})(EventType = exports.EventType || (exports.EventType = {}));\r\n//# sourceMappingURL=../../../ide/js/talon/common/EventType.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Field = void 0;\r\nclass Field {\r\n    constructor() {\r\n        this.name = \"\";\r\n        this.typeName = \"\";\r\n    }\r\n}\r\nexports.Field = Field;\r\n//# sourceMappingURL=../../../ide/js/talon/common/Field.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Instruction = void 0;\r\nconst OpCode_1 = require(\"./OpCode\");\r\nclass Instruction {\r\n    constructor(opCode, value) {\r\n        this.opCode = OpCode_1.OpCode.NoOp;\r\n        this.opCode = opCode;\r\n        this.value = value;\r\n    }\r\n    static assign() {\r\n        return new Instruction(OpCode_1.OpCode.Assign);\r\n    }\r\n    static compareEqual() {\r\n        return new Instruction(OpCode_1.OpCode.CompareEqual);\r\n    }\r\n    static invokeDelegate() {\r\n        return new Instruction(OpCode_1.OpCode.InvokeDelegate);\r\n    }\r\n    static isTypeOf(typeName) {\r\n        return new Instruction(OpCode_1.OpCode.TypeOf, typeName);\r\n    }\r\n    static loadNumber(value) {\r\n        return new Instruction(OpCode_1.OpCode.LoadNumber, value);\r\n    }\r\n    static loadBoolean(value) {\r\n        return new Instruction(OpCode_1.OpCode.LoadBoolean, value);\r\n    }\r\n    static loadString(value) {\r\n        return new Instruction(OpCode_1.OpCode.LoadString, value);\r\n    }\r\n    static loadInstance(typeName) {\r\n        return new Instruction(OpCode_1.OpCode.LoadInstance, typeName);\r\n    }\r\n    static loadField(fieldName) {\r\n        return new Instruction(OpCode_1.OpCode.LoadField, fieldName);\r\n    }\r\n    static loadProperty(fieldName) {\r\n        return new Instruction(OpCode_1.OpCode.LoadProperty, fieldName);\r\n    }\r\n    static loadLocal(localName) {\r\n        return new Instruction(OpCode_1.OpCode.LoadLocal, localName);\r\n    }\r\n    static loadThis() {\r\n        return new Instruction(OpCode_1.OpCode.LoadThis);\r\n    }\r\n    static instanceCall(methodName) {\r\n        return new Instruction(OpCode_1.OpCode.InstanceCall, methodName);\r\n    }\r\n    static concatenate() {\r\n        return new Instruction(OpCode_1.OpCode.Concatenate);\r\n    }\r\n    static staticCall(typeName, methodName) {\r\n        return new Instruction(OpCode_1.OpCode.StaticCall, `${typeName}.${methodName}`);\r\n    }\r\n    static externalCall(methodName) {\r\n        return new Instruction(OpCode_1.OpCode.ExternalCall, methodName);\r\n    }\r\n    static print() {\r\n        return new Instruction(OpCode_1.OpCode.Print);\r\n    }\r\n    static return() {\r\n        return new Instruction(OpCode_1.OpCode.Return);\r\n    }\r\n    static readInput() {\r\n        return new Instruction(OpCode_1.OpCode.ReadInput);\r\n    }\r\n    static parseCommand() {\r\n        return new Instruction(OpCode_1.OpCode.ParseCommand);\r\n    }\r\n    static handleCommand() {\r\n        return new Instruction(OpCode_1.OpCode.HandleCommand);\r\n    }\r\n    static goTo(lineNumber) {\r\n        return new Instruction(OpCode_1.OpCode.GoTo, lineNumber);\r\n    }\r\n    static branchRelative(count) {\r\n        return new Instruction(OpCode_1.OpCode.BranchRelative, count);\r\n    }\r\n    static branchRelativeIfFalse(count) {\r\n        return new Instruction(OpCode_1.OpCode.BranchRelativeIfFalse, count);\r\n    }\r\n    static compareLessThan() {\r\n        return new Instruction(OpCode_1.OpCode.CompareLessThan);\r\n    }\r\n    static add() {\r\n        return new Instruction(OpCode_1.OpCode.Add);\r\n    }\r\n    static loadElement() {\r\n        return new Instruction(OpCode_1.OpCode.LoadElement);\r\n    }\r\n    static setLocal(name) {\r\n        return new Instruction(OpCode_1.OpCode.SetLocal, name);\r\n    }\r\n    static createDelegate(typeName, methodName) {\r\n        return new Instruction(OpCode_1.OpCode.CreateDelegate, `${typeName}:${methodName}`);\r\n    }\r\n    static loadEmpty() {\r\n        return new Instruction(OpCode_1.OpCode.LoadEmpty);\r\n    }\r\n    static newInstance(typeName) {\r\n        return new Instruction(OpCode_1.OpCode.NewInstance, typeName);\r\n    }\r\n    static invokeDelegateOnInstance() {\r\n        return new Instruction(OpCode_1.OpCode.InvokeDelegateOnInstance);\r\n    }\r\n    static ifTrueThen(...instructions) {\r\n        const result = [];\r\n        result.push(Instruction.branchRelativeIfFalse(instructions.length), ...instructions);\r\n        return result;\r\n    }\r\n}\r\nexports.Instruction = Instruction;\r\n//# sourceMappingURL=../../../ide/js/talon/common/Instruction.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Method = void 0;\r\nconst EventType_1 = require(\"./EventType\");\r\nclass Method {\r\n    constructor() {\r\n        this.name = \"\";\r\n        this.parameters = [];\r\n        this.actualParameters = [];\r\n        this.body = [];\r\n        this.returnType = \"\";\r\n        this.eventType = EventType_1.EventType.None;\r\n    }\r\n}\r\nexports.Method = Method;\r\n//# sourceMappingURL=../../../ide/js/talon/common/Method.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.OpCode = void 0;\r\nvar OpCode;\r\n(function (OpCode) {\r\n    OpCode[\"NoOp\"] = \".noop\";\r\n    OpCode[\"Assign\"] = \".set.var\";\r\n    OpCode[\"CompareEqual\"] = \".compare.eq\";\r\n    OpCode[\"Print\"] = \".print\";\r\n    OpCode[\"LoadString\"] = \".load.str\";\r\n    OpCode[\"NewInstance\"] = \".new\";\r\n    OpCode[\"ParseCommand\"] = \".parse.cmd\";\r\n    OpCode[\"HandleCommand\"] = \".handle.cmd\";\r\n    OpCode[\"ReadInput\"] = \".read.in\";\r\n    OpCode[\"GoTo\"] = \".br\";\r\n    OpCode[\"Return\"] = \".ret\";\r\n    OpCode[\"BranchRelative\"] = \".br.rel\";\r\n    OpCode[\"BranchRelativeIfFalse\"] = \".br.rel.false\";\r\n    OpCode[\"Concatenate\"] = \".concat\";\r\n    OpCode[\"LoadNumber\"] = \".load.num\";\r\n    OpCode[\"LoadField\"] = \".load.fld\";\r\n    OpCode[\"LoadProperty\"] = \".load.prop\";\r\n    OpCode[\"LoadInstance\"] = \".load.inst\";\r\n    OpCode[\"LoadLocal\"] = \".load.loc\";\r\n    OpCode[\"LoadThis\"] = \".load.this\";\r\n    OpCode[\"InstanceCall\"] = \".call.inst\";\r\n    OpCode[\"StaticCall\"] = \".call.static\";\r\n    OpCode[\"ExternalCall\"] = \".call.extern\";\r\n    OpCode[\"TypeOf\"] = \".typeof\";\r\n    OpCode[\"InvokeDelegate\"] = \".call.func\";\r\n    OpCode[\"LoadBoolean\"] = \".load.bool\";\r\n    OpCode[\"CompareLessThan\"] = \".compare.lt\";\r\n    OpCode[\"Add\"] = \".add\";\r\n    OpCode[\"LoadElement\"] = \".load.elem\";\r\n    OpCode[\"SetLocal\"] = \".set.local\";\r\n    OpCode[\"CreateDelegate\"] = \".new.dlgt\";\r\n    OpCode[\"LoadEmpty\"] = \".load.empty\";\r\n    OpCode[\"InvokeDelegateOnInstance\"] = \".call.func.inst\";\r\n})(OpCode = exports.OpCode || (exports.OpCode = {}));\r\n//# sourceMappingURL=../../../ide/js/talon/common/OpCode.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Parameter = void 0;\r\nclass Parameter {\r\n    constructor(name, typeName) {\r\n        this.name = name;\r\n        this.typeName = typeName;\r\n    }\r\n}\r\nexports.Parameter = Parameter;\r\n//# sourceMappingURL=../../../ide/js/talon/common/Parameter.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Type = void 0;\r\nclass Type {\r\n    constructor(name, baseTypeName) {\r\n        this.name = name;\r\n        this.baseTypeName = baseTypeName;\r\n        this.fields = [];\r\n        this.methods = [];\r\n        this.attributes = [];\r\n    }\r\n    get isSystemType() {\r\n        return this.name.startsWith(\"~\");\r\n    }\r\n    get isAnonymousType() {\r\n        return this.name.startsWith(\"<~>\");\r\n    }\r\n}\r\nexports.Type = Type;\r\n//# sourceMappingURL=../../../ide/js/talon/common/Type.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Version = void 0;\r\nclass Version {\r\n    constructor(major, minor, patch) {\r\n        this.major = major;\r\n        this.minor = minor;\r\n        this.patch = patch;\r\n    }\r\n    toString() {\r\n        return `${this.major}.${this.minor}.${this.patch}`;\r\n    }\r\n}\r\nexports.Version = Version;\r\n//# sourceMappingURL=../../../ide/js/talon/common/Version.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TalonCompiler = void 0;\r\nconst Type_1 = require(\"../common/Type\");\r\nconst Method_1 = require(\"../common/Method\");\r\nconst Any_1 = require(\"../library/Any\");\r\nconst Instruction_1 = require(\"../common/Instruction\");\r\nconst EntryPointAttribute_1 = require(\"../library/EntryPointAttribute\");\r\nconst TalonLexer_1 = require(\"./lexing/TalonLexer\");\r\nconst TalonParser_1 = require(\"./parsing/TalonParser\");\r\nconst TalonSemanticAnalyzer_1 = require(\"./semantics/TalonSemanticAnalyzer\");\r\nconst TalonTransformer_1 = require(\"./transforming/TalonTransformer\");\r\nconst Version_1 = require(\"../common/Version\");\r\nconst CompilationError_1 = require(\"./exceptions/CompilationError\");\r\nconst Delegate_1 = require(\"../library/Delegate\");\r\nclass TalonCompiler {\r\n    constructor(out) {\r\n        this.out = out;\r\n    }\r\n    get languageVersion() {\r\n        return new Version_1.Version(1, 0, 0);\r\n    }\r\n    get version() {\r\n        return new Version_1.Version(1, 0, 0);\r\n    }\r\n    compile(code) {\r\n        this.out.write(\"<strong>Starting compilation...</strong>\");\r\n        try {\r\n            const lexer = new TalonLexer_1.TalonLexer(this.out);\r\n            const parser = new TalonParser_1.TalonParser(this.out);\r\n            const analyzer = new TalonSemanticAnalyzer_1.TalonSemanticAnalyzer(this.out);\r\n            const transformer = new TalonTransformer_1.TalonTransformer(this.out);\r\n            const tokens = lexer.tokenize(code);\r\n            const ast = parser.parse(tokens);\r\n            const analyzedAst = analyzer.analyze(ast);\r\n            const types = transformer.transform(analyzedAst);\r\n            const entryPoint = this.createEntryPoint();\r\n            types.push(entryPoint);\r\n            return types;\r\n        }\r\n        catch (ex) {\r\n            if (ex instanceof CompilationError_1.CompilationError) {\r\n                this.out.write(`<em>Error: ${ex.message}</em>`);\r\n            }\r\n            else {\r\n                this.out.write(`<em>Unhandled Error: ${ex}</em>`);\r\n            }\r\n            return [];\r\n        }\r\n        finally {\r\n            this.out.write(\"<strong>Compilation complete.</strong>\");\r\n        }\r\n    }\r\n    createEntryPoint() {\r\n        const type = new Type_1.Type(\"~game\", Any_1.Any.typeName);\r\n        type.attributes.push(new EntryPointAttribute_1.EntryPointAttribute());\r\n        const main = new Method_1.Method();\r\n        main.name = Any_1.Any.main;\r\n        main.body.push(Instruction_1.Instruction.loadString(`Talon Language v.${this.languageVersion}, Compiler v.${this.version}`), Instruction_1.Instruction.print(), Instruction_1.Instruction.loadString(\"=================================\"), Instruction_1.Instruction.print(), Instruction_1.Instruction.loadString(\"\"), Instruction_1.Instruction.print(), Instruction_1.Instruction.staticCall(\"~globalSays\", \"~say\"), Instruction_1.Instruction.loadString(\"\"), Instruction_1.Instruction.print(), Instruction_1.Instruction.loadString(\"What would you like to do?\"), Instruction_1.Instruction.print(), Instruction_1.Instruction.readInput(), Instruction_1.Instruction.loadString(\"\"), Instruction_1.Instruction.print(), Instruction_1.Instruction.parseCommand(), Instruction_1.Instruction.handleCommand(), Instruction_1.Instruction.isTypeOf(Delegate_1.Delegate.typeName), Instruction_1.Instruction.branchRelativeIfFalse(2), Instruction_1.Instruction.invokeDelegate(), Instruction_1.Instruction.branchRelative(-4), Instruction_1.Instruction.goTo(7));\r\n        type.methods.push(main);\r\n        return type;\r\n    }\r\n}\r\nexports.TalonCompiler = TalonCompiler;\r\n//# sourceMappingURL=../../../ide/js/talon/compiler/TalonCompiler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CompilationError = void 0;\r\nclass CompilationError {\r\n    constructor(message) {\r\n        this.message = message;\r\n    }\r\n}\r\nexports.CompilationError = CompilationError;\r\n//# sourceMappingURL=../../../../ide/js/talon/compiler/exceptions/CompilationError.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Keywords = void 0;\r\nclass Keywords {\r\n    static getAll() {\r\n        const allKeywords = new Set();\r\n        const names = Object.getOwnPropertyNames(Keywords);\r\n        for (let keyword of names) {\r\n            const value = Keywords[keyword];\r\n            if (typeof value === \"string\" && value != \"Keywords\") {\r\n                allKeywords.add(value);\r\n            }\r\n        }\r\n        return allKeywords;\r\n    }\r\n}\r\nexports.Keywords = Keywords;\r\nKeywords.an = \"an\";\r\nKeywords.a = \"a\";\r\nKeywords.the = \"the\";\r\nKeywords.is = \"is\";\r\nKeywords.kind = \"kind\";\r\nKeywords.of = \"of\";\r\nKeywords.place = \"place\";\r\nKeywords.item = \"item\";\r\nKeywords.it = \"it\";\r\nKeywords.has = \"has\";\r\nKeywords.if = \"if\";\r\nKeywords.description = \"description\";\r\nKeywords.understand = \"understand\";\r\nKeywords.as = \"as\";\r\nKeywords.describing = \"describing\";\r\nKeywords.described = \"described\";\r\nKeywords.where = \"where\";\r\nKeywords.player = \"player\";\r\nKeywords.starts = \"starts\";\r\nKeywords.contains = \"contains\";\r\nKeywords.say = \"say\";\r\nKeywords.directions = \"directions\";\r\nKeywords.moving = \"moving\";\r\nKeywords.taking = \"taking\";\r\nKeywords.inventory = \"inventory\";\r\nKeywords.can = \"can\";\r\nKeywords.reach = \"reach\";\r\nKeywords.by = \"by\";\r\nKeywords.going = \"going\";\r\nKeywords.and = \"and\";\r\nKeywords.or = \"or\";\r\nKeywords.then = \"then\";\r\nKeywords.else = \"else\";\r\nKeywords.when = \"when\";\r\nKeywords.enters = \"enters\";\r\nKeywords.exits = \"exits\";\r\nKeywords.stop = \"stop\";\r\nKeywords.dropping = \"dropping\";\r\nKeywords.that = \"that\";\r\nKeywords.set = \"set\";\r\nKeywords.to = \"to\";\r\nKeywords.decoration = \"decoration\";\r\nKeywords.visible = \"visible\";\r\nKeywords.not = \"not\";\r\nKeywords.observed = \"observed\";\r\nKeywords.continue = \"continue\";\r\nKeywords.true = \"true\";\r\nKeywords.false = \"false\";\r\n//# sourceMappingURL=../../../../ide/js/talon/compiler/lexing/Keywords.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Punctuation = void 0;\r\nclass Punctuation {\r\n}\r\nexports.Punctuation = Punctuation;\r\nPunctuation.period = \".\";\r\nPunctuation.colon = \":\";\r\nPunctuation.semicolon = \";\";\r\nPunctuation.comma = \",\";\r\n//# sourceMappingURL=../../../../ide/js/talon/compiler/lexing/Punctuation.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TalonLexer = void 0;\r\nconst Token_1 = require(\"./Token\");\r\nconst Keywords_1 = require(\"./Keywords\");\r\nconst Punctuation_1 = require(\"./Punctuation\");\r\nconst TokenType_1 = require(\"./TokenType\");\r\nclass TalonLexer {\r\n    constructor(out) {\r\n        this.out = out;\r\n    }\r\n    tokenize(code) {\r\n        let currentLine = 1;\r\n        let currentColumn = 1;\r\n        const tokens = [];\r\n        for (let index = 0; index < code.length;) {\r\n            const currentChar = code.charAt(index);\r\n            if (currentChar == \" \") {\r\n                currentColumn++;\r\n                index++;\r\n                continue;\r\n            }\r\n            if (currentChar == \"\\n\") {\r\n                currentColumn = 1;\r\n                currentLine++;\r\n                index++;\r\n                continue;\r\n            }\r\n            let tokenValue = this.consumeTokenCharsAt(code, index);\r\n            if (tokenValue.length > 0) {\r\n                const token = new Token_1.Token(currentLine, currentColumn, tokenValue);\r\n                tokens.push(token);\r\n            }\r\n            currentColumn += tokenValue.length;\r\n            index += tokenValue.length;\r\n        }\r\n        return this.classify(tokens);\r\n    }\r\n    classify(tokens) {\r\n        for (let token of tokens) {\r\n            if (token.value == Punctuation_1.Punctuation.period) {\r\n                token.type = TokenType_1.TokenType.Terminator;\r\n            }\r\n            else if (token.value == Punctuation_1.Punctuation.semicolon) {\r\n                token.type = TokenType_1.TokenType.SemiTerminator;\r\n            }\r\n            else if (token.value == Punctuation_1.Punctuation.colon) {\r\n                token.type = TokenType_1.TokenType.OpenMethodBlock;\r\n            }\r\n            else if (token.value == Punctuation_1.Punctuation.comma) {\r\n                token.type = TokenType_1.TokenType.ListSeparator;\r\n            }\r\n            else if (token.value === Keywords_1.Keywords.true || token.value === Keywords_1.Keywords.false) {\r\n                token.type = TokenType_1.TokenType.Boolean;\r\n            }\r\n            else if (TalonLexer.allKeywords.has(token.value)) {\r\n                token.type = TokenType_1.TokenType.Keyword;\r\n            }\r\n            else if (token.value.startsWith(\"\\\"\") && token.value.endsWith(\"\\\"\")) {\r\n                token.type = TokenType_1.TokenType.String;\r\n            }\r\n            else if (!isNaN(Number(token.value))) {\r\n                token.type = TokenType_1.TokenType.Number;\r\n            }\r\n            else {\r\n                token.type = TokenType_1.TokenType.Identifier;\r\n            }\r\n        }\r\n        return tokens;\r\n    }\r\n    consumeTokenCharsAt(code, index) {\r\n        const tokenChars = [];\r\n        const stringDelimiter = \"\\\"\";\r\n        let isConsumingString = false;\r\n        for (let readAheadIndex = index; readAheadIndex < code.length; readAheadIndex++) {\r\n            const currentChar = code.charAt(readAheadIndex);\r\n            if (isConsumingString && currentChar != stringDelimiter) {\r\n                tokenChars.push(currentChar);\r\n                continue;\r\n            }\r\n            if (currentChar == stringDelimiter) {\r\n                tokenChars.push(currentChar);\r\n                isConsumingString = !isConsumingString;\r\n                if (isConsumingString) {\r\n                    continue;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            if (currentChar == \" \" ||\r\n                currentChar == \"\\n\" ||\r\n                currentChar == Punctuation_1.Punctuation.period ||\r\n                currentChar == Punctuation_1.Punctuation.colon ||\r\n                currentChar == Punctuation_1.Punctuation.semicolon ||\r\n                currentChar == Punctuation_1.Punctuation.comma) {\r\n                if (tokenChars.length == 0) {\r\n                    tokenChars.push(currentChar);\r\n                }\r\n                break;\r\n            }\r\n            tokenChars.push(currentChar);\r\n        }\r\n        return tokenChars.join(\"\");\r\n    }\r\n}\r\nexports.TalonLexer = TalonLexer;\r\nTalonLexer.allKeywords = Keywords_1.Keywords.getAll();\r\n//# sourceMappingURL=../../../../ide/js/talon/compiler/lexing/TalonLexer.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Token = void 0;\r\nconst TokenType_1 = require(\"./TokenType\");\r\nconst Place_1 = require(\"../../library/Place\");\r\nconst Any_1 = require(\"../../library/Any\");\r\nconst WorldObject_1 = require(\"../../library/WorldObject\");\r\nconst BooleanType_1 = require(\"../../library/BooleanType\");\r\nconst Item_1 = require(\"../../library/Item\");\r\nconst List_1 = require(\"../../library/List\");\r\nconst Decoration_1 = require(\"../../library/Decoration\");\r\nclass Token {\r\n    constructor(line, column, value) {\r\n        this.line = line;\r\n        this.column = column;\r\n        this.value = value;\r\n        this.type = TokenType_1.TokenType.Unknown;\r\n    }\r\n    static get empty() {\r\n        return Token.getTokenWithTypeOf(\"~empty\", TokenType_1.TokenType.Unknown);\r\n    }\r\n    static get forAny() {\r\n        return Token.getTokenWithTypeOf(Any_1.Any.typeName, TokenType_1.TokenType.Keyword);\r\n    }\r\n    static get forPlace() {\r\n        return Token.getTokenWithTypeOf(Place_1.Place.typeName, TokenType_1.TokenType.Keyword);\r\n    }\r\n    static get forItem() {\r\n        return Token.getTokenWithTypeOf(Item_1.Item.typeName, TokenType_1.TokenType.Keyword);\r\n    }\r\n    static get forDecoration() {\r\n        return Token.getTokenWithTypeOf(Decoration_1.Decoration.typeName, TokenType_1.TokenType.Keyword);\r\n    }\r\n    static get forWorldObject() {\r\n        return Token.getTokenWithTypeOf(WorldObject_1.WorldObject.typeName, TokenType_1.TokenType.Keyword);\r\n    }\r\n    static get forBoolean() {\r\n        return Token.getTokenWithTypeOf(BooleanType_1.BooleanType.typeName, TokenType_1.TokenType.Keyword);\r\n    }\r\n    static get forList() {\r\n        return Token.getTokenWithTypeOf(List_1.List.typeName, TokenType_1.TokenType.Keyword);\r\n    }\r\n    static getTokenWithTypeOf(name, type) {\r\n        const token = new Token(-1, -1, name);\r\n        token.type = type;\r\n        return token;\r\n    }\r\n    toString() {\r\n        return `${this.line}, ${this.column}: Found token '${this.value}' of type '${this.type}'`;\r\n    }\r\n}\r\nexports.Token = Token;\r\n//# sourceMappingURL=../../../../ide/js/talon/compiler/lexing/Token.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TokenType = void 0;\r\nvar TokenType;\r\n(function (TokenType) {\r\n    TokenType[\"Unknown\"] = \"Unknown\";\r\n    TokenType[\"Keyword\"] = \"Keyword\";\r\n    TokenType[\"Terminator\"] = \"Terminator\";\r\n    TokenType[\"SemiTerminator\"] = \"SemiTerminator\";\r\n    TokenType[\"String\"] = \"String\";\r\n    TokenType[\"Identifier\"] = \"Identifier\";\r\n    TokenType[\"Number\"] = \"Number\";\r\n    TokenType[\"Boolean\"] = \"Boolean\";\r\n    TokenType[\"OpenMethodBlock\"] = \"OpenMethodBlock\";\r\n    TokenType[\"ListSeparator\"] = \"ListSeparator\";\r\n})(TokenType = exports.TokenType || (exports.TokenType = {}));\r\n//# sourceMappingURL=../../../../ide/js/talon/compiler/lexing/TokenType.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ParseContext = void 0;\r\nconst Token_1 = require(\"../lexing/Token\");\r\nconst CompilationError_1 = require(\"../exceptions/CompilationError\");\r\nconst TokenType_1 = require(\"../lexing/TokenType\");\r\nclass ParseContext {\r\n    constructor(tokens, out) {\r\n        this.tokens = tokens;\r\n        this.out = out;\r\n        this.index = 0;\r\n        this.out.write(`${tokens.length} tokens discovered, parsing...`);\r\n    }\r\n    get isDone() {\r\n        return this.index >= this.tokens.length;\r\n    }\r\n    get currentToken() {\r\n        return this.tokens[this.index];\r\n    }\r\n    get nextToken() {\r\n        return this.tokens[this.index + 1];\r\n    }\r\n    consumeCurrentToken() {\r\n        const token = this.currentToken;\r\n        this.index++;\r\n        return token;\r\n    }\r\n    is(tokenValue) {\r\n        var _a;\r\n        return ((_a = this.currentToken) === null || _a === void 0 ? void 0 : _a.value) == tokenValue;\r\n    }\r\n    isFollowedBy(tokenValue) {\r\n        var _a;\r\n        return ((_a = this.nextToken) === null || _a === void 0 ? void 0 : _a.value) == tokenValue;\r\n    }\r\n    isTypeOf(type) {\r\n        return this.currentToken.type == type;\r\n    }\r\n    isAnyTypeOf(...types) {\r\n        for (const type of types) {\r\n            if (this.isTypeOf(type)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    isAnyOf(...tokenValues) {\r\n        for (let value of tokenValues) {\r\n            if (this.is(value)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    isTerminator() {\r\n        return this.currentToken.type == TokenType_1.TokenType.Terminator;\r\n    }\r\n    expectAnyOf(...tokenValues) {\r\n        if (!this.isAnyOf(...tokenValues)) {\r\n            throw new CompilationError_1.CompilationError(\"Expected tokens\");\r\n        }\r\n        return this.consumeCurrentToken();\r\n    }\r\n    expect(tokenValue) {\r\n        if (this.currentToken.value != tokenValue) {\r\n            throw new CompilationError_1.CompilationError(`Expected token '${tokenValue}'`);\r\n        }\r\n        return this.consumeCurrentToken();\r\n    }\r\n    expectString() {\r\n        const token = this.expectAndConsume(TokenType_1.TokenType.String, \"Expected string\");\r\n        // We need to strip off the double quotes from their string after we consume it.\r\n        return new Token_1.Token(token.line, token.column, token.value.substring(1, token.value.length - 1));\r\n    }\r\n    expectNumber() {\r\n        return this.expectAndConsume(TokenType_1.TokenType.Number, \"Expected number\");\r\n    }\r\n    expectBoolean() {\r\n        return this.expectAndConsume(TokenType_1.TokenType.Boolean, \"Expected boolean\");\r\n    }\r\n    expectIdentifier() {\r\n        return this.expectAndConsume(TokenType_1.TokenType.Identifier, \"Expected identifier\");\r\n    }\r\n    expectTerminator() {\r\n        this.expectAndConsume(TokenType_1.TokenType.Terminator, \"Expected expression terminator\");\r\n    }\r\n    expectSemiTerminator() {\r\n        this.expectAndConsume(TokenType_1.TokenType.SemiTerminator, \"Expected semi expression terminator\");\r\n    }\r\n    expectOpenMethodBlock() {\r\n        this.expectAndConsume(TokenType_1.TokenType.OpenMethodBlock, \"Expected open method block\");\r\n    }\r\n    expectAndConsume(tokenType, errorMessage) {\r\n        if (this.currentToken.type != tokenType) {\r\n            throw this.createCompilationErrorForCurrentToken(errorMessage);\r\n        }\r\n        return this.consumeCurrentToken();\r\n    }\r\n    createCompilationErrorForCurrentToken(message) {\r\n        return new CompilationError_1.CompilationError(`${message}: ${this.currentToken}`);\r\n    }\r\n}\r\nexports.ParseContext = ParseContext;\r\n//# sourceMappingURL=../../../../ide/js/talon/compiler/parsing/ParseContext.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TalonParser = void 0;\r\nconst ProgramVisitor_1 = require(\"./visitors/ProgramVisitor\");\r\nconst ParseContext_1 = require(\"./ParseContext\");\r\nclass TalonParser {\r\n    constructor(out) {\r\n        this.out = out;\r\n    }\r\n    parse(tokens) {\r\n        const context = new ParseContext_1.ParseContext(tokens, this.out);\r\n        const visitor = new ProgramVisitor_1.ProgramVisitor();\r\n        return visitor.visit(context);\r\n    }\r\n}\r\nexports.TalonParser = TalonParser;\r\n//# sourceMappingURL=../../../../ide/js/talon/compiler/parsing/TalonParser.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ActionsExpression = void 0;\r\nconst Expression_1 = require(\"./Expression\");\r\nclass ActionsExpression extends Expression_1.Expression {\r\n    constructor(actions) {\r\n        super();\r\n        this.actions = actions;\r\n    }\r\n}\r\nexports.ActionsExpression = ActionsExpression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/ActionsExpression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BinaryExpression = void 0;\r\nconst Expression_1 = require(\"./Expression\");\r\nclass BinaryExpression extends Expression_1.Expression {\r\n}\r\nexports.BinaryExpression = BinaryExpression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/BinaryExpression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ComparisonExpression = void 0;\r\nconst BinaryExpression_1 = require(\"./BinaryExpression\");\r\nclass ComparisonExpression extends BinaryExpression_1.BinaryExpression {\r\n    constructor(identifier, comparedTo) {\r\n        super();\r\n        this.left = identifier;\r\n        this.right = comparedTo;\r\n    }\r\n}\r\nexports.ComparisonExpression = ComparisonExpression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/ComparisonExpression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ConcatenationExpression = void 0;\r\nconst BinaryExpression_1 = require(\"./BinaryExpression\");\r\nclass ConcatenationExpression extends BinaryExpression_1.BinaryExpression {\r\n}\r\nexports.ConcatenationExpression = ConcatenationExpression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/ConcatenationExpression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ContainsExpression = void 0;\r\nconst Expression_1 = require(\"./Expression\");\r\nclass ContainsExpression extends Expression_1.Expression {\r\n    constructor(targetName, count, typeName) {\r\n        super();\r\n        this.targetName = targetName;\r\n        this.count = count;\r\n        this.typeName = typeName;\r\n    }\r\n}\r\nexports.ContainsExpression = ContainsExpression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/ContainsExpression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Expression = void 0;\r\nclass Expression {\r\n}\r\nexports.Expression = Expression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/Expression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FieldDeclarationExpression = void 0;\r\nconst Expression_1 = require(\"./Expression\");\r\nclass FieldDeclarationExpression extends Expression_1.Expression {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"\";\r\n        this.typeName = \"\";\r\n        this.associatedExpressions = [];\r\n    }\r\n}\r\nexports.FieldDeclarationExpression = FieldDeclarationExpression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/FieldDeclarationExpression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IdentifierExpression = void 0;\r\nconst Expression_1 = require(\"./Expression\");\r\nclass IdentifierExpression extends Expression_1.Expression {\r\n    constructor(instanceName, variableName) {\r\n        super();\r\n        this.instanceName = instanceName;\r\n        this.variableName = variableName;\r\n    }\r\n}\r\nexports.IdentifierExpression = IdentifierExpression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/IdentifierExpression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IfExpression = void 0;\r\nconst Expression_1 = require(\"./Expression\");\r\nclass IfExpression extends Expression_1.Expression {\r\n    constructor(conditional, ifBlock, elseBlock) {\r\n        super();\r\n        this.conditional = conditional;\r\n        this.ifBlock = ifBlock;\r\n        this.elseBlock = elseBlock;\r\n    }\r\n}\r\nexports.IfExpression = IfExpression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/IfExpression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ListExpression = void 0;\r\nconst Expression_1 = require(\"./Expression\");\r\nclass ListExpression extends Expression_1.Expression {\r\n    constructor(items) {\r\n        super();\r\n        this.items = items;\r\n    }\r\n}\r\nexports.ListExpression = ListExpression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/ListExpression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LiteralExpression = void 0;\r\nconst Expression_1 = require(\"./Expression\");\r\nclass LiteralExpression extends Expression_1.Expression {\r\n    constructor(typeName, value) {\r\n        super();\r\n        this.typeName = typeName;\r\n        this.value = value;\r\n    }\r\n}\r\nexports.LiteralExpression = LiteralExpression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/LiteralExpression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ProgramExpression = void 0;\r\nconst Expression_1 = require(\"./Expression\");\r\nclass ProgramExpression extends Expression_1.Expression {\r\n    constructor(expressions) {\r\n        super();\r\n        this.expressions = expressions;\r\n    }\r\n}\r\nexports.ProgramExpression = ProgramExpression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/ProgramExpression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SayExpression = void 0;\r\nconst Expression_1 = require(\"./Expression\");\r\nclass SayExpression extends Expression_1.Expression {\r\n    constructor(text) {\r\n        super();\r\n        this.text = text;\r\n    }\r\n}\r\nexports.SayExpression = SayExpression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/SayExpression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SetVariableExpression = void 0;\r\nconst Expression_1 = require(\"./Expression\");\r\nclass SetVariableExpression extends Expression_1.Expression {\r\n    constructor(instanceName, variableName, evaluationExpression) {\r\n        super();\r\n        this.instanceName = instanceName;\r\n        this.variableName = variableName;\r\n        this.evaluationExpression = evaluationExpression;\r\n    }\r\n}\r\nexports.SetVariableExpression = SetVariableExpression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/SetVariableExpression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TypeDeclarationExpression = void 0;\r\nconst Expression_1 = require(\"./Expression\");\r\nclass TypeDeclarationExpression extends Expression_1.Expression {\r\n    constructor(nameToken, baseTypeNameToken) {\r\n        super();\r\n        this.nameToken = nameToken;\r\n        this.baseTypeNameToken = baseTypeNameToken;\r\n        this.name = \"\";\r\n        this.fields = [];\r\n        this.events = [];\r\n        this.name = nameToken.value;\r\n    }\r\n}\r\nexports.TypeDeclarationExpression = TypeDeclarationExpression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/TypeDeclarationExpression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.UnderstandingDeclarationExpression = void 0;\r\nconst Expression_1 = require(\"./Expression\");\r\nclass UnderstandingDeclarationExpression extends Expression_1.Expression {\r\n    constructor(value, meaning) {\r\n        super();\r\n        this.value = value;\r\n        this.meaning = meaning;\r\n    }\r\n}\r\nexports.UnderstandingDeclarationExpression = UnderstandingDeclarationExpression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/UnderstandingDeclarationExpression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WhenDeclarationExpression = void 0;\r\nconst Expression_1 = require(\"./Expression\");\r\nclass WhenDeclarationExpression extends Expression_1.Expression {\r\n    constructor(actor, eventKind, actions) {\r\n        super();\r\n        this.actor = actor;\r\n        this.eventKind = eventKind;\r\n        this.actions = actions;\r\n    }\r\n}\r\nexports.WhenDeclarationExpression = WhenDeclarationExpression;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/expressions/WhenDeclarationExpression.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BlockExpressionVisitor = void 0;\r\nconst Keywords_1 = require(\"../../lexing/Keywords\");\r\nconst ActionsExpression_1 = require(\"../expressions/ActionsExpression\");\r\nconst ExpressionVisitor_1 = require(\"./ExpressionVisitor\");\r\nconst Visitor_1 = require(\"./Visitor\");\r\nclass BlockExpressionVisitor extends Visitor_1.Visitor {\r\n    visit(context) {\r\n        const actions = [];\r\n        const expressionVisitor = new ExpressionVisitor_1.ExpressionVisitor();\r\n        while (!context.is(Keywords_1.Keywords.and) && !context.is(Keywords_1.Keywords.or)) {\r\n            const action = expressionVisitor.visit(context);\r\n            actions.push(action);\r\n            context.expectSemiTerminator();\r\n        }\r\n        return new ActionsExpression_1.ActionsExpression(actions);\r\n    }\r\n}\r\nexports.BlockExpressionVisitor = BlockExpressionVisitor;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/visitors/BlockExpressionVisitor.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ComparisonExpressionVisitor = void 0;\r\nconst Keywords_1 = require(\"../../lexing/Keywords\");\r\nconst ComparisonExpression_1 = require(\"../expressions/ComparisonExpression\");\r\nconst IdentifierExpression_1 = require(\"../expressions/IdentifierExpression\");\r\nconst ExpressionVisitor_1 = require(\"./ExpressionVisitor\");\r\nconst Visitor_1 = require(\"./Visitor\");\r\nclass ComparisonExpressionVisitor extends Visitor_1.Visitor {\r\n    visit(context) {\r\n        const identifier = context.expectIdentifier();\r\n        const identifierExpression = new IdentifierExpression_1.IdentifierExpression(undefined, identifier.value);\r\n        context.expect(Keywords_1.Keywords.is);\r\n        var visitor = new ExpressionVisitor_1.ExpressionVisitor();\r\n        var comparedTo = visitor.visit(context);\r\n        return new ComparisonExpression_1.ComparisonExpression(identifierExpression, comparedTo);\r\n    }\r\n}\r\nexports.ComparisonExpressionVisitor = ComparisonExpressionVisitor;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/visitors/ComparisonExpressionVisitor.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.EventExpressionVisitor = void 0;\r\nconst ExpressionVisitor_1 = require(\"./ExpressionVisitor\");\r\nconst Keywords_1 = require(\"../../lexing/Keywords\");\r\nconst ActionsExpression_1 = require(\"../expressions/ActionsExpression\");\r\nclass EventExpressionVisitor extends ExpressionVisitor_1.ExpressionVisitor {\r\n    visit(context) {\r\n        const actions = [];\r\n        while (!context.is(Keywords_1.Keywords.and)) {\r\n            const action = super.visit(context);\r\n            actions.push(action);\r\n            context.expectSemiTerminator();\r\n        }\r\n        context.expect(Keywords_1.Keywords.and);\r\n        context.expect(Keywords_1.Keywords.then);\r\n        context.expect(Keywords_1.Keywords.stop);\r\n        context.expectTerminator();\r\n        return new ActionsExpression_1.ActionsExpression(actions);\r\n    }\r\n}\r\nexports.EventExpressionVisitor = EventExpressionVisitor;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/visitors/EventExpressionVisitor.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ExpressionVisitor = void 0;\r\nconst Visitor_1 = require(\"./Visitor\");\r\nconst Keywords_1 = require(\"../../lexing/Keywords\");\r\nconst IfExpressionVisitor_1 = require(\"./IfExpressionVisitor\");\r\nconst CompilationError_1 = require(\"../../exceptions/CompilationError\");\r\nconst ContainsExpression_1 = require(\"../expressions/ContainsExpression\");\r\nconst SayExpression_1 = require(\"../expressions/SayExpression\");\r\nconst TokenType_1 = require(\"../../lexing/TokenType\");\r\nconst SetVariableExpression_1 = require(\"../expressions/SetVariableExpression\");\r\nconst LiteralExpression_1 = require(\"../expressions/LiteralExpression\");\r\nconst NumberType_1 = require(\"../../../library/NumberType\");\r\nconst StringType_1 = require(\"../../../library/StringType\");\r\nconst ListExpression_1 = require(\"../expressions/ListExpression\");\r\nconst ComparisonExpressionVisitor_1 = require(\"./ComparisonExpressionVisitor\");\r\nconst BooleanType_1 = require(\"../../../library/BooleanType\");\r\nconst Convert_1 = require(\"../../../library/Convert\");\r\nclass ExpressionVisitor extends Visitor_1.Visitor {\r\n    visit(context) {\r\n        if (context.is(Keywords_1.Keywords.if)) {\r\n            const visitor = new IfExpressionVisitor_1.IfExpressionVisitor();\r\n            return visitor.visit(context);\r\n        }\r\n        else if (context.is(Keywords_1.Keywords.it)) {\r\n            context.expect(Keywords_1.Keywords.it);\r\n            context.expect(Keywords_1.Keywords.contains);\r\n            const count = context.expectNumber();\r\n            const typeName = context.expectIdentifier();\r\n            return new ContainsExpression_1.ContainsExpression(\"~it\", Number(count.value), typeName.value);\r\n        }\r\n        else if (context.is(Keywords_1.Keywords.set)) {\r\n            context.expect(Keywords_1.Keywords.set);\r\n            let variableName;\r\n            if (context.isTypeOf(TokenType_1.TokenType.Identifier)) {\r\n                variableName = context.expectIdentifier().value;\r\n            }\r\n            else {\r\n                // TODO: Support dereferencing arbitrary instances.\r\n                throw new CompilationError_1.CompilationError(\"Currently unable to dereference a field, planned for a future release\");\r\n            }\r\n            context.expect(Keywords_1.Keywords.to);\r\n            const visitor = new ExpressionVisitor();\r\n            const value = visitor.visit(context);\r\n            return new SetVariableExpression_1.SetVariableExpression(undefined, variableName, value);\r\n        }\r\n        else if (context.is(Keywords_1.Keywords.say)) {\r\n            context.expect(Keywords_1.Keywords.say);\r\n            const text = context.expectString();\r\n            return new SayExpression_1.SayExpression(text.value);\r\n        }\r\n        else if (context.isTypeOf(TokenType_1.TokenType.String)) {\r\n            const value = context.expectString();\r\n            return new LiteralExpression_1.LiteralExpression(StringType_1.StringType.typeName, value.value);\r\n        }\r\n        else if (context.isTypeOf(TokenType_1.TokenType.Number)) {\r\n            const value = context.expectNumber();\r\n            return new LiteralExpression_1.LiteralExpression(NumberType_1.NumberType.typeName, Number(value.value));\r\n        }\r\n        else if (context.isTypeOf(TokenType_1.TokenType.Boolean)) {\r\n            const value = context.expectBoolean();\r\n            return new LiteralExpression_1.LiteralExpression(BooleanType_1.BooleanType.typeName, Convert_1.Convert.stringToBoolean(value.value));\r\n        }\r\n        else if (context.isTypeOf(TokenType_1.TokenType.ListSeparator)) {\r\n            const items = [];\r\n            while (context.isTypeOf(TokenType_1.TokenType.ListSeparator)) {\r\n                context.consumeCurrentToken();\r\n                const item = this.visit(context);\r\n                items.push(item);\r\n            }\r\n            return new ListExpression_1.ListExpression(items);\r\n        }\r\n        else if (context.isFollowedBy(Keywords_1.Keywords.is)) {\r\n            const visitor = new ComparisonExpressionVisitor_1.ComparisonExpressionVisitor();\r\n            return visitor.visit(context);\r\n        }\r\n        else {\r\n            throw new CompilationError_1.CompilationError(`Unable to parse expression at ${context.currentToken}`);\r\n        }\r\n    }\r\n}\r\nexports.ExpressionVisitor = ExpressionVisitor;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/visitors/ExpressionVisitor.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FieldDeclarationVisitor = void 0;\r\nconst Visitor_1 = require(\"./Visitor\");\r\nconst Keywords_1 = require(\"../../lexing/Keywords\");\r\nconst FieldDeclarationExpression_1 = require(\"../expressions/FieldDeclarationExpression\");\r\nconst Place_1 = require(\"../../../library/Place\");\r\nconst BooleanType_1 = require(\"../../../library/BooleanType\");\r\nconst CompilationError_1 = require(\"../../exceptions/CompilationError\");\r\nconst WorldObject_1 = require(\"../../../library/WorldObject\");\r\nconst StringType_1 = require(\"../../../library/StringType\");\r\nconst List_1 = require(\"../../../library/List\");\r\nconst ExpressionVisitor_1 = require(\"./ExpressionVisitor\");\r\nconst ConcatenationExpression_1 = require(\"../expressions/ConcatenationExpression\");\r\nconst TokenType_1 = require(\"../../lexing/TokenType\");\r\nconst NumberType_1 = require(\"../../../library/NumberType\");\r\nclass FieldDeclarationVisitor extends Visitor_1.Visitor {\r\n    visit(context) {\r\n        const field = new FieldDeclarationExpression_1.FieldDeclarationExpression();\r\n        context.expect(Keywords_1.Keywords.it);\r\n        if (context.is(Keywords_1.Keywords.is)) {\r\n            context.expect(Keywords_1.Keywords.is);\r\n            if (context.isAnyOf(Keywords_1.Keywords.not, Keywords_1.Keywords.visible)) {\r\n                let isVisible = true;\r\n                if (context.is(Keywords_1.Keywords.not)) {\r\n                    context.expect(Keywords_1.Keywords.not);\r\n                    isVisible = false;\r\n                }\r\n                context.expect(Keywords_1.Keywords.visible);\r\n                field.name = WorldObject_1.WorldObject.visible;\r\n                field.typeName = BooleanType_1.BooleanType.typeName;\r\n                field.initialValue = isVisible;\r\n            }\r\n            else if (context.is(Keywords_1.Keywords.observed)) {\r\n                context.expect(Keywords_1.Keywords.observed);\r\n                context.expect(Keywords_1.Keywords.as);\r\n                const observation = context.expectString();\r\n                field.name = WorldObject_1.WorldObject.observation;\r\n                field.typeName = StringType_1.StringType.typeName;\r\n                field.initialValue = observation.value;\r\n            }\r\n            else if (context.is(Keywords_1.Keywords.described)) {\r\n                context.expect(Keywords_1.Keywords.described);\r\n                context.expect(Keywords_1.Keywords.as);\r\n                const description = context.expectString();\r\n                field.name = WorldObject_1.WorldObject.description;\r\n                field.typeName = StringType_1.StringType.typeName;\r\n                field.initialValue = description.value;\r\n                while (context.is(Keywords_1.Keywords.and)) {\r\n                    context.expect(Keywords_1.Keywords.and);\r\n                    const expressionVisitor = new ExpressionVisitor_1.ExpressionVisitor();\r\n                    const expression = expressionVisitor.visit(context);\r\n                    const leftExpression = (field.associatedExpressions.length == 0) ? field : field.associatedExpressions[field.associatedExpressions.length - 1];\r\n                    const concat = new ConcatenationExpression_1.ConcatenationExpression();\r\n                    concat.left = leftExpression;\r\n                    concat.right = expression;\r\n                    field.associatedExpressions.push(concat);\r\n                }\r\n            }\r\n            else if (context.is(Keywords_1.Keywords.where)) {\r\n                context.expect(Keywords_1.Keywords.where);\r\n                context.expect(Keywords_1.Keywords.the);\r\n                context.expect(Keywords_1.Keywords.player);\r\n                context.expect(Keywords_1.Keywords.starts);\r\n                field.name = Place_1.Place.isPlayerStart;\r\n                field.typeName = BooleanType_1.BooleanType.typeName;\r\n                field.initialValue = true;\r\n            }\r\n            else {\r\n                throw new CompilationError_1.CompilationError(\"Unable to determine property field\");\r\n            }\r\n        }\r\n        else if (context.is(Keywords_1.Keywords.has)) {\r\n            context.expect(Keywords_1.Keywords.has);\r\n            context.expect(Keywords_1.Keywords.a);\r\n            const name = context.expectIdentifier();\r\n            context.expect(Keywords_1.Keywords.that);\r\n            context.expect(Keywords_1.Keywords.is);\r\n            if (context.isTypeOf(TokenType_1.TokenType.String)) {\r\n                field.typeName = StringType_1.StringType.typeName;\r\n                field.initialValue = context.expectString().value;\r\n            }\r\n            else if (context.isTypeOf(TokenType_1.TokenType.Number)) {\r\n                field.typeName = NumberType_1.NumberType.typeName;\r\n                field.initialValue = context.expectNumber().value;\r\n            }\r\n            else if (context.isTypeOf(TokenType_1.TokenType.Boolean)) {\r\n                field.typeName = BooleanType_1.BooleanType.typeName;\r\n                field.initialValue = context.expectBoolean().value;\r\n            }\r\n            else {\r\n                throw new CompilationError_1.CompilationError(`Expected a string, number, or boolean but found '${context.currentToken.value}' of type '${context.currentToken.type}'`);\r\n            }\r\n            field.name = name.value;\r\n        }\r\n        else if (context.is(Keywords_1.Keywords.contains)) {\r\n            context.expect(Keywords_1.Keywords.contains);\r\n            const expectPair = () => {\r\n                const count = context.expectNumber();\r\n                const name = context.expectIdentifier();\r\n                return [Number(count.value), name.value];\r\n            };\r\n            const items = [expectPair()];\r\n            while (context.isTypeOf(TokenType_1.TokenType.ListSeparator)) {\r\n                context.consumeCurrentToken();\r\n                items.push(expectPair());\r\n            }\r\n            field.name = WorldObject_1.WorldObject.contents;\r\n            field.typeName = List_1.List.typeName;\r\n            field.initialValue = items;\r\n        }\r\n        else if (context.is(Keywords_1.Keywords.can)) {\r\n            context.expect(Keywords_1.Keywords.can);\r\n            context.expect(Keywords_1.Keywords.reach);\r\n            context.expect(Keywords_1.Keywords.the);\r\n            const placeName = context.expectIdentifier();\r\n            context.expect(Keywords_1.Keywords.by);\r\n            context.expect(Keywords_1.Keywords.going);\r\n            const direction = context.expectString();\r\n            field.name = `~${direction.value}`;\r\n            field.typeName = StringType_1.StringType.typeName;\r\n            field.initialValue = `${placeName.value}`;\r\n        }\r\n        else {\r\n            throw new CompilationError_1.CompilationError(\"Unable to determine field\");\r\n        }\r\n        context.expectTerminator();\r\n        return field;\r\n    }\r\n}\r\nexports.FieldDeclarationVisitor = FieldDeclarationVisitor;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/visitors/FieldDeclarationVisitor.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IfExpressionVisitor = void 0;\r\nconst Visitor_1 = require(\"./Visitor\");\r\nconst Keywords_1 = require(\"../../lexing/Keywords\");\r\nconst ExpressionVisitor_1 = require(\"./ExpressionVisitor\");\r\nconst IfExpression_1 = require(\"../expressions/IfExpression\");\r\nconst BlockExpressionVisitor_1 = require(\"./BlockExpressionVisitor\");\r\nconst CompilationError_1 = require(\"../../exceptions/CompilationError\");\r\nclass IfExpressionVisitor extends Visitor_1.Visitor {\r\n    visit(context) {\r\n        context.expect(Keywords_1.Keywords.if);\r\n        const expressionVisitor = new ExpressionVisitor_1.ExpressionVisitor();\r\n        const conditional = expressionVisitor.visit(context);\r\n        context.expect(Keywords_1.Keywords.then);\r\n        const blockVisitor = new BlockExpressionVisitor_1.BlockExpressionVisitor();\r\n        const ifBlock = blockVisitor.visit(context);\r\n        const elseBlock = this.tryVisitElseBlock(context);\r\n        if (context.is(Keywords_1.Keywords.and)) {\r\n            context.expect(Keywords_1.Keywords.and);\r\n            context.expect(Keywords_1.Keywords.then);\r\n            context.expect(Keywords_1.Keywords.continue);\r\n        }\r\n        else {\r\n            throw new CompilationError_1.CompilationError(`You need to end an 'if' expression correctly, not with: ${context.currentToken}`);\r\n        }\r\n        return new IfExpression_1.IfExpression(conditional, ifBlock, elseBlock);\r\n    }\r\n    tryVisitElseBlock(context) {\r\n        if (!context.is(Keywords_1.Keywords.or)) {\r\n            return null;\r\n        }\r\n        const blockVisitor = new BlockExpressionVisitor_1.BlockExpressionVisitor();\r\n        context.expect(Keywords_1.Keywords.or);\r\n        context.expect(Keywords_1.Keywords.else);\r\n        return blockVisitor.visit(context);\r\n    }\r\n}\r\nexports.IfExpressionVisitor = IfExpressionVisitor;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/visitors/IfExpressionVisitor.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ProgramVisitor = void 0;\r\nconst Visitor_1 = require(\"./Visitor\");\r\nconst Keywords_1 = require(\"../../lexing/Keywords\");\r\nconst TypeDeclarationVisitor_1 = require(\"./TypeDeclarationVisitor\");\r\nconst ProgramExpression_1 = require(\"../expressions/ProgramExpression\");\r\nconst CompilationError_1 = require(\"../../exceptions/CompilationError\");\r\nconst UnderstandingDeclarationVisitor_1 = require(\"./UnderstandingDeclarationVisitor\");\r\nconst SayExpressionVisitor_1 = require(\"./SayExpressionVisitor\");\r\nclass ProgramVisitor extends Visitor_1.Visitor {\r\n    visit(context) {\r\n        let expressions = [];\r\n        while (!context.isDone) {\r\n            if (context.is(Keywords_1.Keywords.understand)) {\r\n                const understandingDeclaration = new UnderstandingDeclarationVisitor_1.UnderstandingDeclarationVisitor();\r\n                const expression = understandingDeclaration.visit(context);\r\n                expressions.push(expression);\r\n            }\r\n            else if (context.isAnyOf(Keywords_1.Keywords.a, Keywords_1.Keywords.an)) {\r\n                const typeDeclaration = new TypeDeclarationVisitor_1.TypeDeclarationVisitor();\r\n                const expression = typeDeclaration.visit(context);\r\n                expressions.push(expression);\r\n            }\r\n            else if (context.is(Keywords_1.Keywords.say)) {\r\n                const sayExpression = new SayExpressionVisitor_1.SayExpressionVisitor();\r\n                const expression = sayExpression.visit(context);\r\n                // At the top level, a say expression must have a terminator. We're evaluating it out here\r\n                // because a say expression normally doesn't require one.\r\n                context.expectTerminator();\r\n                expressions.push(expression);\r\n            }\r\n            else {\r\n                throw new CompilationError_1.CompilationError(`Found unexpected token '${context.currentToken}'`);\r\n            }\r\n        }\r\n        return new ProgramExpression_1.ProgramExpression(expressions);\r\n    }\r\n}\r\nexports.ProgramVisitor = ProgramVisitor;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/visitors/ProgramVisitor.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SayExpressionVisitor = void 0;\r\nconst Visitor_1 = require(\"./Visitor\");\r\nconst Keywords_1 = require(\"../../lexing/Keywords\");\r\nconst SayExpression_1 = require(\"../expressions/SayExpression\");\r\nclass SayExpressionVisitor extends Visitor_1.Visitor {\r\n    visit(context) {\r\n        context.expect(Keywords_1.Keywords.say);\r\n        const text = context.expectString();\r\n        return new SayExpression_1.SayExpression(text.value);\r\n    }\r\n}\r\nexports.SayExpressionVisitor = SayExpressionVisitor;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/visitors/SayExpressionVisitor.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TypeDeclarationVisitor = void 0;\r\nconst Visitor_1 = require(\"./Visitor\");\r\nconst Keywords_1 = require(\"../../lexing/Keywords\");\r\nconst TypeDeclarationExpression_1 = require(\"../expressions/TypeDeclarationExpression\");\r\nconst FieldDeclarationVisitor_1 = require(\"./FieldDeclarationVisitor\");\r\nconst WhenDeclarationVisitor_1 = require(\"./WhenDeclarationVisitor\");\r\nclass TypeDeclarationVisitor extends Visitor_1.Visitor {\r\n    visit(context) {\r\n        context.expectAnyOf(Keywords_1.Keywords.a, Keywords_1.Keywords.an);\r\n        const name = context.expectIdentifier();\r\n        context.expect(Keywords_1.Keywords.is);\r\n        context.expect(Keywords_1.Keywords.a);\r\n        context.expect(Keywords_1.Keywords.kind);\r\n        context.expect(Keywords_1.Keywords.of);\r\n        const baseType = this.expectBaseType(context);\r\n        context.expectTerminator();\r\n        const fields = [];\r\n        while (context.is(Keywords_1.Keywords.it)) {\r\n            const fieldVisitor = new FieldDeclarationVisitor_1.FieldDeclarationVisitor();\r\n            const field = fieldVisitor.visit(context);\r\n            fields.push(field);\r\n        }\r\n        const events = [];\r\n        while (context.is(Keywords_1.Keywords.when)) {\r\n            const whenVisitor = new WhenDeclarationVisitor_1.WhenDeclarationVisitor();\r\n            const when = whenVisitor.visit(context);\r\n            events.push(when);\r\n        }\r\n        const typeDeclaration = new TypeDeclarationExpression_1.TypeDeclarationExpression(name, baseType);\r\n        typeDeclaration.fields = fields;\r\n        typeDeclaration.events = events;\r\n        return typeDeclaration;\r\n    }\r\n    expectBaseType(context) {\r\n        if (context.isAnyOf(Keywords_1.Keywords.place, Keywords_1.Keywords.item, Keywords_1.Keywords.decoration)) {\r\n            return context.consumeCurrentToken();\r\n        }\r\n        else {\r\n            return context.expectIdentifier();\r\n        }\r\n    }\r\n}\r\nexports.TypeDeclarationVisitor = TypeDeclarationVisitor;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/visitors/TypeDeclarationVisitor.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.UnderstandingDeclarationVisitor = void 0;\r\nconst Visitor_1 = require(\"./Visitor\");\r\nconst Keywords_1 = require(\"../../lexing/Keywords\");\r\nconst UnderstandingDeclarationExpression_1 = require(\"../expressions/UnderstandingDeclarationExpression\");\r\nclass UnderstandingDeclarationVisitor extends Visitor_1.Visitor {\r\n    visit(context) {\r\n        context.expect(Keywords_1.Keywords.understand);\r\n        const value = context.expectString();\r\n        context.expect(Keywords_1.Keywords.as);\r\n        const meaning = context.expectAnyOf(Keywords_1.Keywords.describing, Keywords_1.Keywords.moving, Keywords_1.Keywords.directions, Keywords_1.Keywords.taking, Keywords_1.Keywords.inventory, Keywords_1.Keywords.dropping);\r\n        context.expectTerminator();\r\n        return new UnderstandingDeclarationExpression_1.UnderstandingDeclarationExpression(value.value, meaning.value);\r\n    }\r\n}\r\nexports.UnderstandingDeclarationVisitor = UnderstandingDeclarationVisitor;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/visitors/UnderstandingDeclarationVisitor.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Visitor = void 0;\r\nclass Visitor {\r\n}\r\nexports.Visitor = Visitor;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/visitors/Visitor.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WhenDeclarationVisitor = void 0;\r\nconst Visitor_1 = require(\"./Visitor\");\r\nconst Keywords_1 = require(\"../../lexing/Keywords\");\r\nconst WhenDeclarationExpression_1 = require(\"../expressions/WhenDeclarationExpression\");\r\nconst EventExpressionVisitor_1 = require(\"./EventExpressionVisitor\");\r\nclass WhenDeclarationVisitor extends Visitor_1.Visitor {\r\n    visit(context) {\r\n        context.expect(Keywords_1.Keywords.when);\r\n        context.expect(Keywords_1.Keywords.the);\r\n        context.expect(Keywords_1.Keywords.player);\r\n        const eventKind = context.expectAnyOf(Keywords_1.Keywords.enters, Keywords_1.Keywords.exits);\r\n        context.expectOpenMethodBlock();\r\n        const actionsVisitor = new EventExpressionVisitor_1.EventExpressionVisitor();\r\n        const actions = actionsVisitor.visit(context);\r\n        return new WhenDeclarationExpression_1.WhenDeclarationExpression(Keywords_1.Keywords.player, eventKind.value, actions);\r\n    }\r\n}\r\nexports.WhenDeclarationVisitor = WhenDeclarationVisitor;\r\n//# sourceMappingURL=../../../../../ide/js/talon/compiler/parsing/visitors/WhenDeclarationVisitor.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TalonSemanticAnalyzer = void 0;\r\nconst ProgramExpression_1 = require(\"../parsing/expressions/ProgramExpression\");\r\nconst TypeDeclarationExpression_1 = require(\"../parsing/expressions/TypeDeclarationExpression\");\r\nconst Token_1 = require(\"../lexing/Token\");\r\nconst TokenType_1 = require(\"../lexing/TokenType\");\r\nclass TalonSemanticAnalyzer {\r\n    constructor(out) {\r\n        this.out = out;\r\n        this.any = new TypeDeclarationExpression_1.TypeDeclarationExpression(Token_1.Token.forAny, Token_1.Token.empty);\r\n        this.worldObject = new TypeDeclarationExpression_1.TypeDeclarationExpression(Token_1.Token.forWorldObject, Token_1.Token.forAny);\r\n        this.place = new TypeDeclarationExpression_1.TypeDeclarationExpression(Token_1.Token.forPlace, Token_1.Token.forWorldObject);\r\n        this.item = new TypeDeclarationExpression_1.TypeDeclarationExpression(Token_1.Token.forItem, Token_1.Token.forWorldObject);\r\n        this.booleanType = new TypeDeclarationExpression_1.TypeDeclarationExpression(Token_1.Token.forBoolean, Token_1.Token.forAny);\r\n        this.list = new TypeDeclarationExpression_1.TypeDeclarationExpression(Token_1.Token.forList, Token_1.Token.forAny);\r\n        this.decoration = new TypeDeclarationExpression_1.TypeDeclarationExpression(Token_1.Token.forDecoration, Token_1.Token.forWorldObject);\r\n    }\r\n    analyze(expression) {\r\n        const types = [this.any, this.worldObject, this.place, this.booleanType, this.item, this.decoration];\r\n        if (expression instanceof ProgramExpression_1.ProgramExpression) {\r\n            for (let child of expression.expressions) {\r\n                if (child instanceof TypeDeclarationExpression_1.TypeDeclarationExpression) {\r\n                    types.push(child);\r\n                }\r\n            }\r\n        }\r\n        const typesByName = new Map(types.map(x => [x.name, x]));\r\n        for (const declaration of types) {\r\n            const baseToken = declaration.baseTypeNameToken;\r\n            if (baseToken.type == TokenType_1.TokenType.Keyword && !baseToken.value.startsWith(\"~\")) {\r\n                const name = `~${baseToken.value}`;\r\n                declaration.baseType = typesByName.get(name);\r\n            }\r\n            else {\r\n                declaration.baseType = typesByName.get(baseToken.value);\r\n            }\r\n            for (const field of declaration.fields) {\r\n                field.type = typesByName.get(field.typeName);\r\n            }\r\n        }\r\n        return expression;\r\n    }\r\n}\r\nexports.TalonSemanticAnalyzer = TalonSemanticAnalyzer;\r\n//# sourceMappingURL=../../../../ide/js/talon/compiler/semantics/TalonSemanticAnalyzer.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ExpressionTransformationMode = void 0;\r\nvar ExpressionTransformationMode;\r\n(function (ExpressionTransformationMode) {\r\n    ExpressionTransformationMode[ExpressionTransformationMode[\"None\"] = 0] = \"None\";\r\n    ExpressionTransformationMode[ExpressionTransformationMode[\"IgnoreResultsOfSayExpression\"] = 1] = \"IgnoreResultsOfSayExpression\";\r\n})(ExpressionTransformationMode = exports.ExpressionTransformationMode || (exports.ExpressionTransformationMode = {}));\r\n//# sourceMappingURL=../../../../ide/js/talon/compiler/transforming/ExpressionTransformationMode.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TalonTransformer = void 0;\r\nconst Type_1 = require(\"../../common/Type\");\r\nconst ProgramExpression_1 = require(\"../parsing/expressions/ProgramExpression\");\r\nconst CompilationError_1 = require(\"../exceptions/CompilationError\");\r\nconst TypeDeclarationExpression_1 = require(\"../parsing/expressions/TypeDeclarationExpression\");\r\nconst UnderstandingDeclarationExpression_1 = require(\"../parsing/expressions/UnderstandingDeclarationExpression\");\r\nconst Understanding_1 = require(\"../../library/Understanding\");\r\nconst Field_1 = require(\"../../common/Field\");\r\nconst Any_1 = require(\"../../library/Any\");\r\nconst WorldObject_1 = require(\"../../library/WorldObject\");\r\nconst Place_1 = require(\"../../library/Place\");\r\nconst BooleanType_1 = require(\"../../library/BooleanType\");\r\nconst StringType_1 = require(\"../../library/StringType\");\r\nconst Item_1 = require(\"../../library/Item\");\r\nconst NumberType_1 = require(\"../../library/NumberType\");\r\nconst List_1 = require(\"../../library/List\");\r\nconst Player_1 = require(\"../../library/Player\");\r\nconst SayExpression_1 = require(\"../parsing/expressions/SayExpression\");\r\nconst Method_1 = require(\"../../common/Method\");\r\nconst Say_1 = require(\"../../library/Say\");\r\nconst Instruction_1 = require(\"../../common/Instruction\");\r\nconst Parameter_1 = require(\"../../common/Parameter\");\r\nconst IfExpression_1 = require(\"../parsing/expressions/IfExpression\");\r\nconst ConcatenationExpression_1 = require(\"../parsing/expressions/ConcatenationExpression\");\r\nconst ContainsExpression_1 = require(\"../parsing/expressions/ContainsExpression\");\r\nconst FieldDeclarationExpression_1 = require(\"../parsing/expressions/FieldDeclarationExpression\");\r\nconst ActionsExpression_1 = require(\"../parsing/expressions/ActionsExpression\");\r\nconst Keywords_1 = require(\"../lexing/Keywords\");\r\nconst EventType_1 = require(\"../../common/EventType\");\r\nconst ExpressionTransformationMode_1 = require(\"./ExpressionTransformationMode\");\r\nconst SetVariableExpression_1 = require(\"../parsing/expressions/SetVariableExpression\");\r\nconst LiteralExpression_1 = require(\"../parsing/expressions/LiteralExpression\");\r\nconst Decoration_1 = require(\"../../library/Decoration\");\r\nconst ComparisonExpression_1 = require(\"../parsing/expressions/ComparisonExpression\");\r\nconst IdentifierExpression_1 = require(\"../parsing/expressions/IdentifierExpression\");\r\nconst Convert_1 = require(\"../../library/Convert\");\r\nclass TalonTransformer {\r\n    constructor(out) {\r\n        this.out = out;\r\n    }\r\n    createSystemTypes() {\r\n        const types = [];\r\n        // These are only here as stubs for external runtime types that allow us to correctly resolve field types.\r\n        types.push(new Type_1.Type(Any_1.Any.typeName, Any_1.Any.parentTypeName));\r\n        types.push(new Type_1.Type(WorldObject_1.WorldObject.typeName, WorldObject_1.WorldObject.parentTypeName));\r\n        types.push(new Type_1.Type(Place_1.Place.typeName, Place_1.Place.parentTypeName));\r\n        types.push(new Type_1.Type(BooleanType_1.BooleanType.typeName, BooleanType_1.BooleanType.parentTypeName));\r\n        types.push(new Type_1.Type(StringType_1.StringType.typeName, StringType_1.StringType.parentTypeName));\r\n        types.push(new Type_1.Type(NumberType_1.NumberType.typeName, NumberType_1.NumberType.parentTypeName));\r\n        types.push(new Type_1.Type(Item_1.Item.typeName, Item_1.Item.parentTypeName));\r\n        types.push(new Type_1.Type(List_1.List.typeName, List_1.List.parentTypeName));\r\n        types.push(new Type_1.Type(Player_1.Player.typeName, Player_1.Player.parentTypeName));\r\n        types.push(new Type_1.Type(Say_1.Say.typeName, Say_1.Say.parentTypeName));\r\n        types.push(new Type_1.Type(Decoration_1.Decoration.typeName, Decoration_1.Decoration.parentTypeName));\r\n        return new Map(types.map(x => [x.name, x]));\r\n    }\r\n    transform(expression) {\r\n        const typesByName = this.createSystemTypes();\r\n        let dynamicTypeCount = 0;\r\n        if (expression instanceof ProgramExpression_1.ProgramExpression) {\r\n            for (const child of expression.expressions) {\r\n                if (child instanceof UnderstandingDeclarationExpression_1.UnderstandingDeclarationExpression) {\r\n                    const type = new Type_1.Type(`~${Understanding_1.Understanding.typeName}_${dynamicTypeCount}`, Understanding_1.Understanding.typeName);\r\n                    const action = new Field_1.Field();\r\n                    action.name = Understanding_1.Understanding.action;\r\n                    action.defaultValue = child.value;\r\n                    const meaning = new Field_1.Field();\r\n                    meaning.name = Understanding_1.Understanding.meaning;\r\n                    meaning.defaultValue = child.meaning;\r\n                    type.fields.push(action);\r\n                    type.fields.push(meaning);\r\n                    dynamicTypeCount++;\r\n                    typesByName.set(type.name, type);\r\n                }\r\n                else if (child instanceof TypeDeclarationExpression_1.TypeDeclarationExpression) {\r\n                    const type = this.transformInitialTypeDeclaration(child);\r\n                    typesByName.set(type.name, type);\r\n                }\r\n            }\r\n            for (const child of expression.expressions) {\r\n                if (child instanceof TypeDeclarationExpression_1.TypeDeclarationExpression) {\r\n                    const type = typesByName.get(child.name);\r\n                    for (const fieldExpression of child.fields) {\r\n                        const field = new Field_1.Field();\r\n                        field.name = fieldExpression.name;\r\n                        field.typeName = fieldExpression.typeName;\r\n                        field.type = typesByName.get(fieldExpression.typeName);\r\n                        if (fieldExpression.initialValue) {\r\n                            if (field.typeName == StringType_1.StringType.typeName) {\r\n                                const value = fieldExpression.initialValue;\r\n                                field.defaultValue = value;\r\n                            }\r\n                            else if (field.typeName == NumberType_1.NumberType.typeName) {\r\n                                const value = Number(fieldExpression.initialValue);\r\n                                field.defaultValue = value;\r\n                            }\r\n                            else if (field.typeName == BooleanType_1.BooleanType.typeName) {\r\n                                let value = false;\r\n                                if (typeof fieldExpression.initialValue == 'string') {\r\n                                    value = Convert_1.Convert.stringToBoolean(fieldExpression.initialValue);\r\n                                }\r\n                                else if (typeof fieldExpression.initialValue == 'boolean') {\r\n                                    value = fieldExpression.initialValue;\r\n                                }\r\n                                else {\r\n                                    throw new CompilationError_1.CompilationError(`Unable to transform field type`);\r\n                                }\r\n                                field.defaultValue = value;\r\n                            }\r\n                            else {\r\n                                field.defaultValue = fieldExpression.initialValue;\r\n                            }\r\n                        }\r\n                        if (fieldExpression.associatedExpressions.length > 0) {\r\n                            const getField = new Method_1.Method();\r\n                            getField.name = `~get_${field.name}`;\r\n                            getField.parameters.push(new Parameter_1.Parameter(\"~value\", field.typeName));\r\n                            getField.returnType = field.typeName;\r\n                            for (const associated of fieldExpression.associatedExpressions) {\r\n                                getField.body.push(...this.transformExpression(associated));\r\n                            }\r\n                            getField.body.push(Instruction_1.Instruction.return());\r\n                            type === null || type === void 0 ? void 0 : type.methods.push(getField);\r\n                        }\r\n                        type === null || type === void 0 ? void 0 : type.fields.push(field);\r\n                    }\r\n                    let isWorldObject = false;\r\n                    for (let current = type; current; current = typesByName.get(current.baseTypeName)) {\r\n                        if (current.name == WorldObject_1.WorldObject.typeName) {\r\n                            isWorldObject = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (isWorldObject) {\r\n                        const describe = new Method_1.Method();\r\n                        describe.name = WorldObject_1.WorldObject.describe;\r\n                        describe.body.push(Instruction_1.Instruction.loadThis(), Instruction_1.Instruction.loadProperty(WorldObject_1.WorldObject.visible), Instruction_1.Instruction.branchRelativeIfFalse(10), Instruction_1.Instruction.loadThis(), Instruction_1.Instruction.loadProperty(WorldObject_1.WorldObject.description), Instruction_1.Instruction.loadString(' '), Instruction_1.Instruction.loadThis(), Instruction_1.Instruction.createDelegate(type === null || type === void 0 ? void 0 : type.name, WorldObject_1.WorldObject.observe), Instruction_1.Instruction.loadThis(), Instruction_1.Instruction.loadProperty(WorldObject_1.WorldObject.contents), Instruction_1.Instruction.instanceCall(List_1.List.map), Instruction_1.Instruction.instanceCall(List_1.List.join), Instruction_1.Instruction.concatenate(), Instruction_1.Instruction.print(), Instruction_1.Instruction.return());\r\n                        type === null || type === void 0 ? void 0 : type.methods.push(describe);\r\n                        const observe = new Method_1.Method();\r\n                        observe.name = WorldObject_1.WorldObject.observe;\r\n                        observe.returnType = StringType_1.StringType.typeName;\r\n                        observe.body.push(Instruction_1.Instruction.loadThis(), Instruction_1.Instruction.loadProperty(WorldObject_1.WorldObject.visible), ...Instruction_1.Instruction.ifTrueThen(Instruction_1.Instruction.loadThis(), Instruction_1.Instruction.loadProperty(WorldObject_1.WorldObject.observation), Instruction_1.Instruction.return()), Instruction_1.Instruction.loadString(\"\"), Instruction_1.Instruction.return());\r\n                        type === null || type === void 0 ? void 0 : type.methods.push(observe);\r\n                        if (!(type === null || type === void 0 ? void 0 : type.fields.find(x => x.name == WorldObject_1.WorldObject.visible))) {\r\n                            const visible = new Field_1.Field();\r\n                            visible.name = WorldObject_1.WorldObject.visible;\r\n                            visible.typeName = BooleanType_1.BooleanType.typeName;\r\n                            visible.defaultValue = true;\r\n                            type === null || type === void 0 ? void 0 : type.fields.push(visible);\r\n                        }\r\n                        if (!(type === null || type === void 0 ? void 0 : type.fields.find(x => x.name == WorldObject_1.WorldObject.contents))) {\r\n                            const contents = new Field_1.Field();\r\n                            contents.name = WorldObject_1.WorldObject.contents;\r\n                            contents.typeName = List_1.List.typeName;\r\n                            contents.defaultValue = [];\r\n                            type === null || type === void 0 ? void 0 : type.fields.push(contents);\r\n                        }\r\n                        if (!(type === null || type === void 0 ? void 0 : type.fields.find(x => x.name == WorldObject_1.WorldObject.observation))) {\r\n                            const observation = new Field_1.Field();\r\n                            observation.name = WorldObject_1.WorldObject.observation;\r\n                            observation.typeName = StringType_1.StringType.typeName;\r\n                            observation.defaultValue = \"\";\r\n                            type === null || type === void 0 ? void 0 : type.fields.push(observation);\r\n                        }\r\n                        let duplicateEventCount = 0;\r\n                        for (const event of child.events) {\r\n                            const method = new Method_1.Method();\r\n                            method.name = `~event_${event.actor}_${event.eventKind}_${duplicateEventCount}`;\r\n                            method.eventType = this.transformEventKind(event.eventKind);\r\n                            duplicateEventCount++;\r\n                            const actions = event.actions;\r\n                            for (const action of actions.actions) {\r\n                                const body = this.transformExpression(action, ExpressionTransformationMode_1.ExpressionTransformationMode.IgnoreResultsOfSayExpression);\r\n                                method.body.push(...body);\r\n                            }\r\n                            method.body.push(Instruction_1.Instruction.return());\r\n                            type === null || type === void 0 ? void 0 : type.methods.push(method);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            const globalSays = expression.expressions.filter(x => x instanceof SayExpression_1.SayExpression);\r\n            const type = new Type_1.Type(`~globalSays`, Say_1.Say.typeName);\r\n            const method = new Method_1.Method();\r\n            method.name = Say_1.Say.typeName;\r\n            method.parameters = [];\r\n            const instructions = [];\r\n            for (const say of globalSays) {\r\n                const sayExpression = say;\r\n                instructions.push(Instruction_1.Instruction.loadString(sayExpression.text), Instruction_1.Instruction.print());\r\n            }\r\n            instructions.push(Instruction_1.Instruction.return());\r\n            method.body = instructions;\r\n            type.methods.push(method);\r\n            typesByName.set(type.name, type);\r\n        }\r\n        else {\r\n            throw new CompilationError_1.CompilationError(\"Unable to partially transform\");\r\n        }\r\n        this.out.write(`Created ${typesByName.size} types...`);\r\n        return Array.from(typesByName.values());\r\n    }\r\n    transformEventKind(kind) {\r\n        switch (kind) {\r\n            case Keywords_1.Keywords.enters: {\r\n                return EventType_1.EventType.PlayerEntersPlace;\r\n            }\r\n            case Keywords_1.Keywords.exits: {\r\n                return EventType_1.EventType.PlayerExitsPlace;\r\n            }\r\n            default: {\r\n                throw new CompilationError_1.CompilationError(`Unable to transform unsupported event kind '${kind}'`);\r\n            }\r\n        }\r\n    }\r\n    transformExpression(expression, mode) {\r\n        const instructions = [];\r\n        if (expression == null) {\r\n            return instructions;\r\n        }\r\n        if (expression instanceof IfExpression_1.IfExpression) {\r\n            const conditional = this.transformExpression(expression.conditional, mode);\r\n            instructions.push(...conditional);\r\n            const ifBlock = this.transformExpression(expression.ifBlock, mode);\r\n            const elseBlock = this.transformExpression(expression.elseBlock, mode);\r\n            ifBlock.push(Instruction_1.Instruction.branchRelative(elseBlock.length));\r\n            instructions.push(Instruction_1.Instruction.branchRelativeIfFalse(ifBlock.length));\r\n            instructions.push(...ifBlock);\r\n            instructions.push(...elseBlock);\r\n        }\r\n        else if (expression instanceof SayExpression_1.SayExpression) {\r\n            instructions.push(Instruction_1.Instruction.loadString(expression.text));\r\n            instructions.push(Instruction_1.Instruction.print());\r\n            if (mode != ExpressionTransformationMode_1.ExpressionTransformationMode.IgnoreResultsOfSayExpression) {\r\n                instructions.push(Instruction_1.Instruction.loadString(expression.text));\r\n            }\r\n        }\r\n        else if (expression instanceof ContainsExpression_1.ContainsExpression) {\r\n            instructions.push(Instruction_1.Instruction.loadNumber(expression.count), Instruction_1.Instruction.loadString(expression.typeName), Instruction_1.Instruction.loadInstance(expression.targetName), Instruction_1.Instruction.loadField(WorldObject_1.WorldObject.contents), Instruction_1.Instruction.instanceCall(List_1.List.contains));\r\n        }\r\n        else if (expression instanceof ConcatenationExpression_1.ConcatenationExpression) {\r\n            const left = this.transformExpression(expression.left, mode);\r\n            const right = this.transformExpression(expression.right, mode);\r\n            instructions.push(...left);\r\n            instructions.push(...right);\r\n            instructions.push(Instruction_1.Instruction.concatenate());\r\n        }\r\n        else if (expression instanceof FieldDeclarationExpression_1.FieldDeclarationExpression) {\r\n            instructions.push(Instruction_1.Instruction.loadThis(), Instruction_1.Instruction.loadField(expression.name));\r\n        }\r\n        else if (expression instanceof SetVariableExpression_1.SetVariableExpression) {\r\n            const right = this.transformExpression(expression.evaluationExpression);\r\n            instructions.push(...right, Instruction_1.Instruction.loadThis(), Instruction_1.Instruction.loadField(expression.variableName), Instruction_1.Instruction.assign());\r\n        }\r\n        else if (expression instanceof LiteralExpression_1.LiteralExpression) {\r\n            if (expression.typeName == StringType_1.StringType.typeName) {\r\n                instructions.push(Instruction_1.Instruction.loadString(expression.value));\r\n            }\r\n            else if (expression.typeName == NumberType_1.NumberType.typeName) {\r\n                instructions.push(Instruction_1.Instruction.loadNumber(Number(expression.value)));\r\n            }\r\n            else if (expression.typeName == BooleanType_1.BooleanType.typeName) {\r\n                instructions.push(Instruction_1.Instruction.loadBoolean((expression.value)));\r\n            }\r\n            else {\r\n                throw new CompilationError_1.CompilationError(`Unable to transform unsupported literal expression '${expression}'`);\r\n            }\r\n        }\r\n        else if (expression instanceof IdentifierExpression_1.IdentifierExpression) {\r\n            instructions.push(Instruction_1.Instruction.loadThis(), Instruction_1.Instruction.loadField(expression.variableName));\r\n        }\r\n        else if (expression instanceof ComparisonExpression_1.ComparisonExpression) {\r\n            const right = this.transformExpression(expression.right);\r\n            const left = this.transformExpression(expression.left);\r\n            instructions.push(...left, ...right, Instruction_1.Instruction.compareEqual());\r\n        }\r\n        else if (expression instanceof ActionsExpression_1.ActionsExpression) {\r\n            expression.actions.forEach(x => instructions.push(...this.transformExpression(x, mode)));\r\n        }\r\n        else {\r\n            throw new CompilationError_1.CompilationError(`Unable to transform unsupported expression: ${expression}`);\r\n        }\r\n        return instructions;\r\n    }\r\n    transformInitialTypeDeclaration(expression) {\r\n        return new Type_1.Type(expression.name, expression.baseType.name);\r\n    }\r\n}\r\nexports.TalonTransformer = TalonTransformer;\r\n//# sourceMappingURL=../../../../ide/js/talon/compiler/transforming/TalonTransformer.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AnalysisCoordinator = void 0;\r\nclass AnalysisCoordinator {\r\n    constructor(analyzer, output) {\r\n        this.analyzer = analyzer;\r\n        this.output = output;\r\n        analyzer.currentPane.addEventListener(\"keyup\", e => this.update());\r\n        analyzer.currentPane.addEventListener(\"click\", e => this.update());\r\n    }\r\n    update() {\r\n        this.updateCaretPositionValues();\r\n    }\r\n    updateCaretPositionValues() {\r\n        const position = this.analyzer.currentCaretPosition;\r\n        const formattedPosition = `Line ${position.row}, Column ${position.column}`;\r\n        this.output.innerHTML = formattedPosition;\r\n    }\r\n}\r\nexports.AnalysisCoordinator = AnalysisCoordinator;\r\n//# sourceMappingURL=../../../ide/js/talon/ide/AnalysisCoordinator.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CaretPosition = void 0;\r\nclass CaretPosition {\r\n    constructor(row, column) {\r\n        this.row = row;\r\n        this.column = column;\r\n    }\r\n}\r\nexports.CaretPosition = CaretPosition;\r\n//# sourceMappingURL=../../../ide/js/talon/ide/CaretPosition.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CodePaneAnalyzer = void 0;\r\nconst CaretPosition_1 = require(\"../CaretPosition\");\r\nclass CodePaneAnalyzer {\r\n    constructor(pane) {\r\n        this.pane = pane;\r\n        this.caretRow = 0;\r\n        this.caretColumn = 0;\r\n        pane.addEventListener(\"keyup\", e => this.updateCurrentCaretPosition());\r\n        pane.addEventListener(\"click\", e => this.updateCurrentCaretPosition());\r\n    }\r\n    get currentCaretPosition() {\r\n        return new CaretPosition_1.CaretPosition(this.caretRow, this.caretColumn);\r\n    }\r\n    get currentPane() {\r\n        return this.pane;\r\n    }\r\n    updateCurrentCaretPosition() {\r\n        var sel = document.getSelection(); // Using 'any' because 'modify' isn't officially supported.\r\n        if (sel.toString().length > 0) {\r\n            return;\r\n        }\r\n        sel.modify(\"extend\", \"backward\", \"lineboundary\");\r\n        var position = sel.toString().length;\r\n        if (sel.anchorNode != undefined) {\r\n            sel.collapseToEnd();\r\n        }\r\n        this.caretColumn = position;\r\n        sel = document.getSelection();\r\n        sel.modify(\"extend\", \"backward\", \"documentboundary\");\r\n        this.caretRow = ((sel.toString().substring(0)).split(\"\\n\")).length;\r\n        if (sel.anchorNode != undefined) {\r\n            sel.collapseToEnd();\r\n        }\r\n    }\r\n}\r\nexports.CodePaneAnalyzer = CodePaneAnalyzer;\r\n//# sourceMappingURL=../../../../ide/js/talon/ide/analyzers/CodePaneAnalyzer.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CodePaneStyleFormatter = void 0;\r\nclass CodePaneStyleFormatter {\r\n    constructor(pane) {\r\n        this.pane = pane;\r\n        this.pane.addEventListener('keydown', e => {\r\n            if (e.key === \"Tab\") {\r\n                e.preventDefault();\r\n            }\r\n        });\r\n        this.pane.addEventListener('keyup', e => {\r\n            if (e.key === \"Tab\") {\r\n                e.preventDefault();\r\n                let selection = window.getSelection();\r\n                selection.collapseToStart();\r\n                let range = selection.getRangeAt(0);\r\n                range.insertNode(document.createTextNode(\"    \"));\r\n                selection.collapseToEnd();\r\n            }\r\n        });\r\n    }\r\n    get currentPane() {\r\n        return this.pane;\r\n    }\r\n}\r\nexports.CodePaneStyleFormatter = CodePaneStyleFormatter;\r\n//# sourceMappingURL=../../../../ide/js/talon/ide/formatters/CodePaneStyleFormatter.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Any = void 0;\r\nconst ExternCall_1 = require(\"./ExternCall\");\r\nclass Any {\r\n}\r\nexports.Any = Any;\r\nAny.parentTypeName = \"\";\r\nAny.typeName = \"~any\";\r\nAny.main = \"~main\";\r\nAny.externToString = ExternCall_1.ExternCall.of(\"~toString\");\r\n//# sourceMappingURL=../../../ide/js/talon/library/Any.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BooleanType = void 0;\r\nconst Any_1 = require(\"./Any\");\r\nclass BooleanType {\r\n}\r\nexports.BooleanType = BooleanType;\r\nBooleanType.parentTypeName = Any_1.Any.typeName;\r\nBooleanType.typeName = \"~boolean\";\r\n//# sourceMappingURL=../../../ide/js/talon/library/BooleanType.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Convert = void 0;\r\nconst Keywords_1 = require(\"../compiler/lexing/Keywords\");\r\nclass Convert {\r\n    static stringToNumber(value) {\r\n        return Number(value);\r\n    }\r\n    static stringToBoolean(value) {\r\n        return value.toLowerCase() == Keywords_1.Keywords.true;\r\n    }\r\n}\r\nexports.Convert = Convert;\r\n//# sourceMappingURL=../../../ide/js/talon/library/Convert.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Decoration = void 0;\r\nconst WorldObject_1 = require(\"./WorldObject\");\r\nclass Decoration {\r\n}\r\nexports.Decoration = Decoration;\r\nDecoration.parentTypeName = WorldObject_1.WorldObject.typeName;\r\nDecoration.typeName = \"~decoration\";\r\n//# sourceMappingURL=../../../ide/js/talon/library/Decoration.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Delegate = void 0;\r\nconst Any_1 = require(\"./Any\");\r\nclass Delegate {\r\n}\r\nexports.Delegate = Delegate;\r\nDelegate.typeName = \"~delegate\";\r\nDelegate.parentTypeName = Any_1.Any.typeName;\r\n//# sourceMappingURL=../../../ide/js/talon/library/Delegate.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.EntryPointAttribute = void 0;\r\nclass EntryPointAttribute {\r\n    constructor() {\r\n        this.name = \"~entryPoint\";\r\n    }\r\n}\r\nexports.EntryPointAttribute = EntryPointAttribute;\r\n//# sourceMappingURL=../../../ide/js/talon/library/EntryPointAttribute.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ExternCall = void 0;\r\nclass ExternCall {\r\n    constructor(name, ...args) {\r\n        this.name = \"\";\r\n        this.args = [];\r\n        this.name = name;\r\n        this.args = args;\r\n    }\r\n    static of(name, ...args) {\r\n        return new ExternCall(name, ...args);\r\n    }\r\n}\r\nexports.ExternCall = ExternCall;\r\n//# sourceMappingURL=../../../ide/js/talon/library/ExternCall.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Item = void 0;\r\nconst WorldObject_1 = require(\"./WorldObject\");\r\nclass Item {\r\n}\r\nexports.Item = Item;\r\nItem.typeName = \"~item\";\r\nItem.parentTypeName = WorldObject_1.WorldObject.typeName;\r\n//# sourceMappingURL=../../../ide/js/talon/library/Item.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.List = void 0;\r\nconst Any_1 = require(\"./Any\");\r\nclass List {\r\n}\r\nexports.List = List;\r\nList.typeName = \"~list\";\r\nList.parentTypeName = Any_1.Any.typeName;\r\nList.count = \"~count\";\r\nList.add = \"~add\";\r\nList.map = \"~map\";\r\nList.contains = \"~contains\";\r\nList.join = \"~join\";\r\nList.separatorParameter = \"~separator\";\r\nList.instanceParameter = \"~instance\";\r\nList.delegateParameter = \"~delegate\";\r\nList.typeNameParameter = \"~typeName\";\r\nList.countParameter = \"~count\";\r\n//# sourceMappingURL=../../../ide/js/talon/library/List.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NumberType = void 0;\r\nconst Any_1 = require(\"./Any\");\r\nclass NumberType {\r\n}\r\nexports.NumberType = NumberType;\r\nNumberType.typeName = \"~number\";\r\nNumberType.parentTypeName = Any_1.Any.typeName;\r\n//# sourceMappingURL=../../../ide/js/talon/library/NumberType.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Place = void 0;\r\nconst WorldObject_1 = require(\"./WorldObject\");\r\nclass Place {\r\n}\r\nexports.Place = Place;\r\nPlace.parentTypeName = WorldObject_1.WorldObject.typeName;\r\nPlace.typeName = \"~place\";\r\nPlace.isPlayerStart = \"~isPlayerStart\";\r\n//# sourceMappingURL=../../../ide/js/talon/library/Place.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Player = void 0;\r\nconst WorldObject_1 = require(\"./WorldObject\");\r\nclass Player {\r\n}\r\nexports.Player = Player;\r\nPlayer.typeName = \"~player\";\r\nPlayer.parentTypeName = WorldObject_1.WorldObject.typeName;\r\n//# sourceMappingURL=../../../ide/js/talon/library/Player.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Say = void 0;\r\nconst Any_1 = require(\"./Any\");\r\nclass Say {\r\n}\r\nexports.Say = Say;\r\nSay.typeName = \"~say\";\r\nSay.parentTypeName = Any_1.Any.typeName;\r\n//# sourceMappingURL=../../../ide/js/talon/library/Say.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.StringType = void 0;\r\nconst Any_1 = require(\"./Any\");\r\nclass StringType {\r\n}\r\nexports.StringType = StringType;\r\nStringType.parentTypeName = Any_1.Any.typeName;\r\nStringType.typeName = \"~string\";\r\n//# sourceMappingURL=../../../ide/js/talon/library/StringType.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Understanding = void 0;\r\nconst Any_1 = require(\"./Any\");\r\nclass Understanding {\r\n}\r\nexports.Understanding = Understanding;\r\nUnderstanding.parentTypeName = Any_1.Any.typeName;\r\nUnderstanding.typeName = \"~understanding\";\r\nUnderstanding.describing = \"~describing\";\r\nUnderstanding.moving = \"~moving\";\r\nUnderstanding.direction = \"~direction\";\r\nUnderstanding.taking = \"~taking\";\r\nUnderstanding.inventory = \"~inventory\";\r\nUnderstanding.dropping = \"~dropping\";\r\nUnderstanding.action = \"~action\";\r\nUnderstanding.meaning = \"~meaning\";\r\n//# sourceMappingURL=../../../ide/js/talon/library/Understanding.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WorldObject = void 0;\r\nconst Any_1 = require(\"./Any\");\r\nclass WorldObject {\r\n}\r\nexports.WorldObject = WorldObject;\r\nWorldObject.parentTypeName = Any_1.Any.typeName;\r\nWorldObject.typeName = \"~worldObject\";\r\nWorldObject.description = \"~description\";\r\nWorldObject.contents = \"~contents\";\r\nWorldObject.observation = \"~observation\";\r\nWorldObject.describe = \"~describe\";\r\nWorldObject.observe = \"~observe\";\r\nWorldObject.visible = \"~visible\";\r\n//# sourceMappingURL=../../../ide/js/talon/library/WorldObject.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.EvaluationResult = void 0;\r\nvar EvaluationResult;\r\n(function (EvaluationResult) {\r\n    EvaluationResult[EvaluationResult[\"Continue\"] = 0] = \"Continue\";\r\n    EvaluationResult[EvaluationResult[\"SuspendForInput\"] = 1] = \"SuspendForInput\";\r\n})(EvaluationResult = exports.EvaluationResult || (exports.EvaluationResult = {}));\r\n//# sourceMappingURL=../../../ide/js/talon/runtime/EvaluationResult.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MethodActivation = void 0;\r\nconst StackFrame_1 = require(\"./StackFrame\");\r\nconst RuntimeError_1 = require(\"./errors/RuntimeError\");\r\nclass MethodActivation {\r\n    constructor(method) {\r\n        this.stack = [];\r\n        this.method = method;\r\n        this.stackFrame = new StackFrame_1.StackFrame(method);\r\n    }\r\n    stackSize() {\r\n        return this.stack.length;\r\n    }\r\n    peek() {\r\n        if (this.stack.length == 0) {\r\n            throw new RuntimeError_1.RuntimeError(`Stack Imbalance! Attempted to peek an empty stack.`);\r\n        }\r\n        return this.stack[this.stack.length - 1];\r\n    }\r\n    pop() {\r\n        if (this.stack.length == 0) {\r\n            throw new RuntimeError_1.RuntimeError(`Stack Imbalance! Attempted to pop an empty stack.`);\r\n        }\r\n        return this.stack.pop();\r\n    }\r\n    push(runtimeAny) {\r\n        this.stack.push(runtimeAny);\r\n    }\r\n}\r\nexports.MethodActivation = MethodActivation;\r\n//# sourceMappingURL=../../../ide/js/talon/runtime/MethodActivation.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.OpCodeHandler = void 0;\r\nconst EvaluationResult_1 = require(\"./EvaluationResult\");\r\nclass OpCodeHandler {\r\n    logInteraction(thread, ...parameters) {\r\n        var _a;\r\n        let formattedLine = this.code.toString();\r\n        if (parameters && parameters.length > 0) {\r\n            formattedLine += ' ' + parameters.join(' ');\r\n        }\r\n        (_a = thread.log) === null || _a === void 0 ? void 0 : _a.debug(formattedLine);\r\n    }\r\n    handle(thread) {\r\n        return EvaluationResult_1.EvaluationResult.Continue;\r\n    }\r\n}\r\nexports.OpCodeHandler = OpCodeHandler;\r\n//# sourceMappingURL=../../../ide/js/talon/runtime/OpCodeHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RuntimeState = void 0;\r\nvar RuntimeState;\r\n(function (RuntimeState) {\r\n    RuntimeState[RuntimeState[\"Stopped\"] = 0] = \"Stopped\";\r\n    RuntimeState[RuntimeState[\"Loaded\"] = 1] = \"Loaded\";\r\n    RuntimeState[RuntimeState[\"Started\"] = 2] = \"Started\";\r\n})(RuntimeState = exports.RuntimeState || (exports.RuntimeState = {}));\r\n//# sourceMappingURL=../../../ide/js/talon/runtime/RuntimeState.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.StackFrame = void 0;\r\nconst Variable_1 = require(\"./library/Variable\");\r\nclass StackFrame {\r\n    constructor(method) {\r\n        this.locals = [];\r\n        this.currentInstruction = -1;\r\n        for (var parameter of method.parameters) {\r\n            const variable = new Variable_1.Variable(parameter.name, parameter.type);\r\n            this.locals.push(variable);\r\n        }\r\n    }\r\n}\r\nexports.StackFrame = StackFrame;\r\n//# sourceMappingURL=../../../ide/js/talon/runtime/StackFrame.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TalonRuntime = void 0;\r\nconst Thread_1 = require(\"./Thread\");\r\nconst EntryPointAttribute_1 = require(\"../library/EntryPointAttribute\");\r\nconst Any_1 = require(\"../library/Any\");\r\nconst MethodActivation_1 = require(\"./MethodActivation\");\r\nconst EvaluationResult_1 = require(\"./EvaluationResult\");\r\nconst OpCode_1 = require(\"../common/OpCode\");\r\nconst PrintHandler_1 = require(\"./handlers/PrintHandler\");\r\nconst NoOpHandler_1 = require(\"./handlers/NoOpHandler\");\r\nconst LoadStringHandler_1 = require(\"./handlers/LoadStringHandler\");\r\nconst NewInstanceHandler_1 = require(\"./handlers/NewInstanceHandler\");\r\nconst Memory_1 = require(\"./common/Memory\");\r\nconst ReadInputHandler_1 = require(\"./handlers/ReadInputHandler\");\r\nconst ParseCommandHandler_1 = require(\"./handlers/ParseCommandHandler\");\r\nconst GoToHandler_1 = require(\"./handlers/GoToHandler\");\r\nconst HandleCommandHandler_1 = require(\"./handlers/HandleCommandHandler\");\r\nconst Place_1 = require(\"../library/Place\");\r\nconst Player_1 = require(\"../library/Player\");\r\nconst ReturnHandler_1 = require(\"./handlers/ReturnHandler\");\r\nconst StaticCallHandler_1 = require(\"./handlers/StaticCallHandler\");\r\nconst RuntimeError_1 = require(\"./errors/RuntimeError\");\r\nconst LoadInstanceHandler_1 = require(\"./handlers/LoadInstanceHandler\");\r\nconst LoadNumberHandler_1 = require(\"./handlers/LoadNumberHandler\");\r\nconst InstanceCallHandler_1 = require(\"./handlers/InstanceCallHandler\");\r\nconst LoadPropertyHandler_1 = require(\"./handlers/LoadPropertyHandler\");\r\nconst LoadFieldHandler_1 = require(\"./handlers/LoadFieldHandler\");\r\nconst ExternalCallHandler_1 = require(\"./handlers/ExternalCallHandler\");\r\nconst LoadLocalHandler_1 = require(\"./handlers/LoadLocalHandler\");\r\nconst LoadThisHandler_1 = require(\"./handlers/LoadThisHandler\");\r\nconst BranchRelativeHandler_1 = require(\"./handlers/BranchRelativeHandler\");\r\nconst BranchRelativeIfFalseHandler_1 = require(\"./handlers/BranchRelativeIfFalseHandler\");\r\nconst ConcatenateHandler_1 = require(\"./handlers/ConcatenateHandler\");\r\nconst AssignVariableHandler_1 = require(\"./handlers/AssignVariableHandler\");\r\nconst TypeOfHandler_1 = require(\"./handlers/TypeOfHandler\");\r\nconst InvokeDelegateHandler_1 = require(\"./handlers/InvokeDelegateHandler\");\r\nconst ComparisonHandler_1 = require(\"./handlers/ComparisonHandler\");\r\nconst RuntimeState_1 = require(\"./RuntimeState\");\r\nconst StateMachine_1 = require(\"./common/StateMachine\");\r\nconst State_1 = require(\"./common/State\");\r\nconst LoadBooleanHandler_1 = require(\"./handlers/LoadBooleanHandler\");\r\nconst CreateDelegateHandler_1 = require(\"./handlers/CreateDelegateHandler\");\r\nconst CompareLessThanHandler_1 = require(\"./handlers/CompareLessThanHandler\");\r\nconst AddHandler_1 = require(\"./handlers/AddHandler\");\r\nconst LoadElementHandler_1 = require(\"./handlers/LoadElementHandler\");\r\nconst SetLocalHandler_1 = require(\"./handlers/SetLocalHandler\");\r\nconst LoadEmptyHandler_1 = require(\"./handlers/LoadEmptyHandler\");\r\nconst InvokeDelegateOnInstanceHandler_1 = require(\"./handlers/InvokeDelegateOnInstanceHandler\");\r\nclass TalonRuntime {\r\n    constructor(userOutput, logOutput) {\r\n        this.userOutput = userOutput;\r\n        this.logOutput = logOutput;\r\n        this.userOutput = userOutput;\r\n        const handlerInstances = [\r\n            new NoOpHandler_1.NoOpHandler(),\r\n            new LoadStringHandler_1.LoadStringHandler(),\r\n            new PrintHandler_1.PrintHandler(this.userOutput),\r\n            new NewInstanceHandler_1.NewInstanceHandler(),\r\n            new ReadInputHandler_1.ReadInputHandler(),\r\n            new ParseCommandHandler_1.ParseCommandHandler(),\r\n            new HandleCommandHandler_1.HandleCommandHandler(this.userOutput),\r\n            new GoToHandler_1.GoToHandler(),\r\n            new ReturnHandler_1.ReturnHandler(),\r\n            new StaticCallHandler_1.StaticCallHandler(),\r\n            new LoadInstanceHandler_1.LoadInstanceHandler(),\r\n            new LoadNumberHandler_1.LoadNumberHandler(),\r\n            new LoadBooleanHandler_1.LoadBooleanHandler(),\r\n            new InstanceCallHandler_1.InstanceCallHandler(),\r\n            new LoadPropertyHandler_1.LoadPropertyHandler(),\r\n            new LoadFieldHandler_1.LoadFieldHandler(),\r\n            new ExternalCallHandler_1.ExternalCallHandler(),\r\n            new LoadLocalHandler_1.LoadLocalHandler(),\r\n            new LoadThisHandler_1.LoadThisHandler(),\r\n            new BranchRelativeHandler_1.BranchRelativeHandler(),\r\n            new BranchRelativeIfFalseHandler_1.BranchRelativeIfFalseHandler(),\r\n            new ConcatenateHandler_1.ConcatenateHandler(),\r\n            new AssignVariableHandler_1.AssignVariableHandler(),\r\n            new TypeOfHandler_1.TypeOfHandler(),\r\n            new InvokeDelegateHandler_1.InvokeDelegateHandler(),\r\n            new ComparisonHandler_1.ComparisonHandler(),\r\n            new CreateDelegateHandler_1.CreateDelegateHandler(),\r\n            new CompareLessThanHandler_1.CompareLessThanHandler(),\r\n            new AddHandler_1.AddHandler(),\r\n            new LoadElementHandler_1.LoadElementHandler(),\r\n            new SetLocalHandler_1.SetLocalHandler(),\r\n            new LoadEmptyHandler_1.LoadEmptyHandler(),\r\n            new InvokeDelegateOnInstanceHandler_1.InvokeDelegateOnInstanceHandler()\r\n        ];\r\n        this.handlers = new Map(handlerInstances.map(x => [x.code, x]));\r\n        this.state = new StateMachine_1.StateMachine(new State_1.State(RuntimeState_1.RuntimeState.Stopped, (current) => current.state !== RuntimeState_1.RuntimeState.Stopped), new State_1.State(RuntimeState_1.RuntimeState.Loaded, (current) => {\r\n            var _a;\r\n            if (current.state === RuntimeState_1.RuntimeState.Started) {\r\n                (_a = this.logOutput) === null || _a === void 0 ? void 0 : _a.debug(\"The runtime has already been started and can't load more types.\");\r\n                return false;\r\n            }\r\n            return true;\r\n        }), new State_1.State(RuntimeState_1.RuntimeState.Started, (current) => {\r\n            var _a, _b;\r\n            if (current.state === RuntimeState_1.RuntimeState.Started) {\r\n                (_a = this.logOutput) === null || _a === void 0 ? void 0 : _a.debug(\"The runtime has already been started.\");\r\n                return false;\r\n            }\r\n            else if (current.state === RuntimeState_1.RuntimeState.Stopped) {\r\n                (_b = this.logOutput) === null || _b === void 0 ? void 0 : _b.debug(\"The runtime must be loaded with types prior to being started.\");\r\n                return false;\r\n            }\r\n            return true;\r\n        }));\r\n    }\r\n    start() {\r\n        var _a, _b;\r\n        if (!this.state.tryMoveTo(RuntimeState_1.RuntimeState.Started)) {\r\n            return;\r\n        }\r\n        const places = (_a = this.thread) === null || _a === void 0 ? void 0 : _a.allTypes.filter(x => x.baseTypeName == Place_1.Place.typeName).map(x => Memory_1.Memory.allocate(x));\r\n        const getPlayerStart = (place) => { var _a; return ((_a = place.fields.get(Place_1.Place.isPlayerStart)) === null || _a === void 0 ? void 0 : _a.value); };\r\n        const isPlayerStart = (place) => { var _a; return ((_a = getPlayerStart(place)) === null || _a === void 0 ? void 0 : _a.value) === true; };\r\n        const currentPlace = places === null || places === void 0 ? void 0 : places.find(isPlayerStart);\r\n        this.thread.currentPlace = currentPlace;\r\n        const player = (_b = this.thread) === null || _b === void 0 ? void 0 : _b.knownTypes.get(Player_1.Player.typeName);\r\n        this.thread.currentPlayer = Memory_1.Memory.allocate(player);\r\n        this.runWith(\"\");\r\n    }\r\n    stop() {\r\n        if (!this.state.tryMoveTo(RuntimeState_1.RuntimeState.Stopped)) {\r\n            return;\r\n        }\r\n        Memory_1.Memory.clear();\r\n        this.thread = undefined;\r\n    }\r\n    loadFrom(types) {\r\n        var _a;\r\n        if (types.length == 0) {\r\n            (_a = this.logOutput) === null || _a === void 0 ? void 0 : _a.debug(\"No types were provided, unable to load runtime.\");\r\n            return false;\r\n        }\r\n        if (!this.state.tryMoveTo(RuntimeState_1.RuntimeState.Loaded)) {\r\n            return false;\r\n        }\r\n        Memory_1.Memory.clear();\r\n        const loadedTypes = Memory_1.Memory.loadTypes(types);\r\n        const entryPoint = loadedTypes.find(x => x.attributes.findIndex(attribute => attribute instanceof EntryPointAttribute_1.EntryPointAttribute) > -1);\r\n        const mainMethod = entryPoint === null || entryPoint === void 0 ? void 0 : entryPoint.methods.find(x => x.name == Any_1.Any.main);\r\n        const activation = new MethodActivation_1.MethodActivation(mainMethod);\r\n        this.thread = new Thread_1.Thread(loadedTypes, activation);\r\n        this.thread.log = this.logOutput;\r\n        return true;\r\n    }\r\n    sendCommand(input) {\r\n        this.runWith(input);\r\n    }\r\n    runWith(command) {\r\n        // We're going to keep their command in the visual history to make things easier to understand.\r\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\r\n        this.userOutput.write(command);\r\n        // Now we can go ahead and process their command.\r\n        const instruction = this.thread.currentInstruction;\r\n        if ((instruction === null || instruction === void 0 ? void 0 : instruction.opCode) == OpCode_1.OpCode.ReadInput) {\r\n            const text = Memory_1.Memory.allocateString(command);\r\n            (_a = this.thread) === null || _a === void 0 ? void 0 : _a.currentMethod.push(text);\r\n            (_b = this.thread) === null || _b === void 0 ? void 0 : _b.moveNext();\r\n        }\r\n        if (((_c = this.thread) === null || _c === void 0 ? void 0 : _c.currentInstruction) == undefined) {\r\n            (_d = this.thread) === null || _d === void 0 ? void 0 : _d.moveNext();\r\n        }\r\n        if (((_e = this.thread) === null || _e === void 0 ? void 0 : _e.currentInstruction) == undefined) {\r\n            throw new RuntimeError_1.RuntimeError(\"Unable to execute command, no instruction found\");\r\n        }\r\n        try {\r\n            for (let instruction = this.evaluateCurrentInstruction(); instruction == EvaluationResult_1.EvaluationResult.Continue; instruction = this.evaluateCurrentInstruction()) {\r\n                (_f = this.thread) === null || _f === void 0 ? void 0 : _f.moveNext();\r\n            }\r\n        }\r\n        catch (ex) {\r\n            if (ex instanceof RuntimeError_1.RuntimeError) {\r\n                (_g = this.logOutput) === null || _g === void 0 ? void 0 : _g.debug(`Runtime Error: ${ex.message}`);\r\n                (_h = this.logOutput) === null || _h === void 0 ? void 0 : _h.debug(`Stack Trace: ${ex.stack}`);\r\n            }\r\n            else {\r\n                (_j = this.logOutput) === null || _j === void 0 ? void 0 : _j.debug(`Encountered unhandled error: ${ex}`);\r\n            }\r\n        }\r\n    }\r\n    evaluateCurrentInstruction() {\r\n        var _a;\r\n        const instruction = (_a = this.thread) === null || _a === void 0 ? void 0 : _a.currentInstruction;\r\n        const handler = this.handlers.get(instruction === null || instruction === void 0 ? void 0 : instruction.opCode);\r\n        if (handler == undefined) {\r\n            throw new RuntimeError_1.RuntimeError(`Encountered unsupported OpCode '${instruction === null || instruction === void 0 ? void 0 : instruction.opCode}'`);\r\n        }\r\n        return handler === null || handler === void 0 ? void 0 : handler.handle(this.thread);\r\n    }\r\n}\r\nexports.TalonRuntime = TalonRuntime;\r\n//# sourceMappingURL=../../../ide/js/talon/runtime/TalonRuntime.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Thread = void 0;\r\nconst MethodActivation_1 = require(\"./MethodActivation\");\r\nconst Understanding_1 = require(\"../library/Understanding\");\r\nconst RuntimeEmpty_1 = require(\"./library/RuntimeEmpty\");\r\nclass Thread {\r\n    constructor(types, method) {\r\n        this.allTypes = [];\r\n        this.knownTypes = new Map();\r\n        this.knownUnderstandings = [];\r\n        this.knownPlaces = [];\r\n        this.methods = [];\r\n        this.allTypes = types;\r\n        this.knownTypes = new Map(types.map(type => [type.name, type]));\r\n        this.knownUnderstandings = types.filter(x => x.baseTypeName === Understanding_1.Understanding.typeName);\r\n        this.methods.push(method);\r\n    }\r\n    get currentMethod() {\r\n        return this.methods[this.methods.length - 1];\r\n    }\r\n    get currentInstruction() {\r\n        var _a;\r\n        const activation = this.currentMethod;\r\n        return (_a = activation.method) === null || _a === void 0 ? void 0 : _a.body[activation.stackFrame.currentInstruction];\r\n    }\r\n    currentInstructionValueAs() {\r\n        var _a;\r\n        return (_a = this.currentInstruction) === null || _a === void 0 ? void 0 : _a.value;\r\n    }\r\n    activateMethod(method) {\r\n        var _a, _b;\r\n        const activation = new MethodActivation_1.MethodActivation(method);\r\n        const current = this.currentMethod;\r\n        (_a = this.log) === null || _a === void 0 ? void 0 : _a.debug(`${(_b = current.method) === null || _b === void 0 ? void 0 : _b.name} => ${method.name}`);\r\n        this.methods.push(activation);\r\n    }\r\n    moveNext() {\r\n        this.currentMethod.stackFrame.currentInstruction++;\r\n    }\r\n    jumpToLine(lineNumber) {\r\n        this.currentMethod.stackFrame.currentInstruction = lineNumber;\r\n    }\r\n    returnFromCurrentMethod() {\r\n        var _a, _b, _c;\r\n        const expectReturnType = this.currentMethod.method.returnType != \"\";\r\n        const returnedMethod = this.methods.pop();\r\n        (_a = this.log) === null || _a === void 0 ? void 0 : _a.debug(`${(_b = this.currentMethod.method) === null || _b === void 0 ? void 0 : _b.name} <= ${(_c = returnedMethod === null || returnedMethod === void 0 ? void 0 : returnedMethod.method) === null || _c === void 0 ? void 0 : _c.name}`);\r\n        if (!expectReturnType) {\r\n            return new RuntimeEmpty_1.RuntimeEmpty();\r\n        }\r\n        const returnValue = returnedMethod === null || returnedMethod === void 0 ? void 0 : returnedMethod.stack.pop();\r\n        return returnValue;\r\n    }\r\n}\r\nexports.Thread = Thread;\r\n//# sourceMappingURL=../../../ide/js/talon/runtime/Thread.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Memory = void 0;\r\nconst Place_1 = require(\"../../library/Place\");\r\nconst RuntimePlace_1 = require(\"../library/RuntimePlace\");\r\nconst RuntimeError_1 = require(\"../errors/RuntimeError\");\r\nconst Variable_1 = require(\"../library/Variable\");\r\nconst StringType_1 = require(\"../../library/StringType\");\r\nconst RuntimeString_1 = require(\"../library/RuntimeString\");\r\nconst RuntimeEmpty_1 = require(\"../library/RuntimeEmpty\");\r\nconst RuntimeCommand_1 = require(\"../library/RuntimeCommand\");\r\nconst BooleanType_1 = require(\"../../library/BooleanType\");\r\nconst RuntimeBoolean_1 = require(\"../library/RuntimeBoolean\");\r\nconst List_1 = require(\"../../library/List\");\r\nconst RuntimeList_1 = require(\"../library/RuntimeList\");\r\nconst Item_1 = require(\"../../library/Item\");\r\nconst RuntimeItem_1 = require(\"../library/RuntimeItem\");\r\nconst Player_1 = require(\"../../library/Player\");\r\nconst RuntimePlayer_1 = require(\"../library/RuntimePlayer\");\r\nconst Say_1 = require(\"../../library/Say\");\r\nconst RuntimeSay_1 = require(\"../library/RuntimeSay\");\r\nconst RuntimeInteger_1 = require(\"../library/RuntimeInteger\");\r\nconst NumberType_1 = require(\"../../library/NumberType\");\r\nconst RuntimeDecoration_1 = require(\"../library/RuntimeDecoration\");\r\nconst Decoration_1 = require(\"../../library/Decoration\");\r\nclass Memory {\r\n    static clear() {\r\n        Memory.typesByName = new Map();\r\n        Memory.heap = new Map();\r\n    }\r\n    static findTypeByName(name) {\r\n        if (!this.typesByName.has(name)) {\r\n            throw new RuntimeError_1.RuntimeError(`Unable to locate type '${name}'`);\r\n        }\r\n        return this.typesByName.get(name);\r\n    }\r\n    static findInstanceByName(name) {\r\n        const instances = Memory.heap.get(name);\r\n        if (!instances || instances.length == 0) {\r\n            throw new RuntimeError_1.RuntimeError(\"Object not found\");\r\n        }\r\n        if (instances.length > 1) {\r\n            throw new RuntimeError_1.RuntimeError(\"Located more than one instance\");\r\n        }\r\n        return instances[0];\r\n    }\r\n    static loadTypes(types) {\r\n        Memory.typesByName = new Map(types.map(x => [x.name, x]));\r\n        // Override any provided type stubs with the actual runtime type definitions.\r\n        const place = RuntimePlace_1.RuntimePlace.type;\r\n        const item = RuntimeItem_1.RuntimeItem.type;\r\n        const player = RuntimePlayer_1.RuntimePlayer.type;\r\n        const decoration = RuntimeDecoration_1.RuntimeDecoration.type;\r\n        Memory.typesByName.set(place.name, place);\r\n        Memory.typesByName.set(item.name, item);\r\n        Memory.typesByName.set(player.name, player);\r\n        Memory.typesByName.set(decoration.name, decoration);\r\n        return Array.from(Memory.typesByName.values());\r\n    }\r\n    static allocateCommand() {\r\n        return new RuntimeCommand_1.RuntimeCommand();\r\n    }\r\n    static allocateBoolean(value) {\r\n        return new RuntimeBoolean_1.RuntimeBoolean(value);\r\n    }\r\n    static allocateNumber(value) {\r\n        return new RuntimeInteger_1.RuntimeInteger(value);\r\n    }\r\n    static allocateString(text) {\r\n        return new RuntimeString_1.RuntimeString(text);\r\n    }\r\n    static allocate(type) {\r\n        const instance = Memory.constructInstanceFrom(type);\r\n        const instancePool = Memory.heap.get(type.name) || [];\r\n        instancePool.push(instance);\r\n        Memory.heap.set(type.name, instancePool);\r\n        return instance;\r\n    }\r\n    static initializeVariableWith(field) {\r\n        const variable = Memory.constructVariableFrom(field);\r\n        variable.value = Memory.instantiateDefaultValueFor(variable, field.defaultValue);\r\n        return variable;\r\n    }\r\n    static constructVariableFrom(field) {\r\n        if (field.type) {\r\n            return new Variable_1.Variable(field.name, field.type);\r\n        }\r\n        const type = Memory.typesByName.get(field.typeName);\r\n        if (!type) {\r\n            throw new RuntimeError_1.RuntimeError(`Unable to construct unknown type '${field.typeName}'`);\r\n        }\r\n        return new Variable_1.Variable(field.name, type);\r\n    }\r\n    static instantiateDefaultValueFor(variable, defaultValue) {\r\n        switch (variable.type.name) {\r\n            case StringType_1.StringType.typeName: return new RuntimeString_1.RuntimeString(defaultValue ? defaultValue : \"\");\r\n            case BooleanType_1.BooleanType.typeName: return new RuntimeBoolean_1.RuntimeBoolean(defaultValue ? defaultValue : false);\r\n            case NumberType_1.NumberType.typeName: return new RuntimeInteger_1.RuntimeInteger(defaultValue ? defaultValue : 0);\r\n            case List_1.List.typeName: return new RuntimeList_1.RuntimeList(defaultValue ? this.instantiateList(defaultValue) : []);\r\n            default:\r\n                return new RuntimeEmpty_1.RuntimeEmpty();\r\n        }\r\n    }\r\n    static instantiateList(items) {\r\n        const runtimeItems = [];\r\n        for (const item of items) {\r\n            const itemList = item;\r\n            const count = itemList[0];\r\n            const typeName = itemList[1];\r\n            const type = Memory.typesByName.get(typeName);\r\n            for (let current = 0; current < count; current++) {\r\n                const instance = Memory.allocate(type);\r\n                runtimeItems.push(instance);\r\n            }\r\n        }\r\n        return runtimeItems;\r\n    }\r\n    static constructInstanceFrom(type) {\r\n        let seenTypes = new Set();\r\n        let inheritanceChain = [];\r\n        for (let current = type; current; current = Memory.typesByName.get(current.baseTypeName)) {\r\n            if (seenTypes.has(current.name)) {\r\n                throw new RuntimeError_1.RuntimeError(\"You can't have cycles in a type hierarchy\");\r\n            }\r\n            seenTypes.add(current.name);\r\n            inheritanceChain.push(current);\r\n        }\r\n        const firstSystemTypeAncestorIndex = inheritanceChain.findIndex(x => x.isSystemType);\r\n        if (firstSystemTypeAncestorIndex < 0) {\r\n            throw new RuntimeError_1.RuntimeError(\"Type must ultimately inherit from a system type\");\r\n        }\r\n        const instance = this.allocateSystemTypeByName(inheritanceChain[firstSystemTypeAncestorIndex].name);\r\n        instance.parentTypeName = instance.typeName;\r\n        instance.typeName = inheritanceChain[0].name;\r\n        // TODO: Inherit more than just fields/methods.\r\n        // TODO: Type check field inheritance for shadowing/overriding.\r\n        // Inherit fields/methods from types in the hierarchy from least to most derived.\r\n        for (let i = firstSystemTypeAncestorIndex; i >= 0; i--) {\r\n            const currentType = inheritanceChain[i];\r\n            for (const field of currentType.fields) {\r\n                const variable = this.initializeVariableWith(field);\r\n                instance.fields.set(field.name, variable);\r\n            }\r\n            for (const method of currentType.methods) {\r\n                instance.methods.set(method.name, method);\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n    static allocateSystemTypeByName(typeName) {\r\n        switch (typeName) {\r\n            case Place_1.Place.typeName: return new RuntimePlace_1.RuntimePlace();\r\n            case Item_1.Item.typeName: return new RuntimeItem_1.RuntimeItem();\r\n            case Player_1.Player.typeName: return new RuntimePlayer_1.RuntimePlayer();\r\n            case List_1.List.typeName: return new RuntimeList_1.RuntimeList([]);\r\n            case Say_1.Say.typeName: return new RuntimeSay_1.RuntimeSay();\r\n            case Decoration_1.Decoration.typeName: return new RuntimeDecoration_1.RuntimeDecoration();\r\n            default: {\r\n                throw new RuntimeError_1.RuntimeError(`Unable to instantiate type '${typeName}'`);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.Memory = Memory;\r\nMemory.typesByName = new Map();\r\nMemory.heap = new Map();\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/common/Memory.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.State = void 0;\r\nclass State {\r\n    constructor(state, ...preconditions) {\r\n        this.state = state;\r\n        this.preconditions = [];\r\n        if (preconditions) {\r\n            preconditions.forEach(x => this.preconditions.push(x));\r\n        }\r\n    }\r\n    static empty() {\r\n        return new State();\r\n    }\r\n}\r\nexports.State = State;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/common/State.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.StateMachine = void 0;\r\nconst RuntimeError_1 = require(\"../errors/RuntimeError\");\r\nconst State_1 = require(\"./State\");\r\nclass StateMachine {\r\n    constructor(...states) {\r\n        this.currentState = State_1.State.empty();\r\n        this.statesByContent = new Map(states.map(x => [x.state, x]));\r\n    }\r\n    getState(state) {\r\n        const current = this.statesByContent.get(state);\r\n        if (!current) {\r\n            throw new RuntimeError_1.RuntimeError(`Unable to get unknown state '${state}`);\r\n        }\r\n        return current;\r\n    }\r\n    initializeTo(state) {\r\n        this.currentState = this.getState(state);\r\n    }\r\n    tryMoveTo(state) {\r\n        const attemptedState = this.getState(state);\r\n        if (!attemptedState.preconditions.every(x => x(this.currentState))) {\r\n            return false;\r\n        }\r\n        this.currentState = attemptedState;\r\n        return true;\r\n    }\r\n}\r\nexports.StateMachine = StateMachine;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/common/StateMachine.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RuntimeError = void 0;\r\nclass RuntimeError extends Error {\r\n    constructor(message) {\r\n        super(message);\r\n    }\r\n}\r\nexports.RuntimeError = RuntimeError;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/errors/RuntimeError.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AddHandler = void 0;\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nconst Memory_1 = require(\"../common/Memory\");\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nclass AddHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.Add;\r\n    }\r\n    handle(thread) {\r\n        this.logInteraction(thread);\r\n        const first = thread.currentMethod.pop();\r\n        const second = thread.currentMethod.pop();\r\n        const added = Memory_1.Memory.allocateNumber(first.value + second.value);\r\n        thread.currentMethod.push(added);\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.AddHandler = AddHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/AddHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AssignVariableHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst RuntimeString_1 = require(\"../library/RuntimeString\");\r\nconst RuntimeError_1 = require(\"../errors/RuntimeError\");\r\nconst RuntimeInteger_1 = require(\"../library/RuntimeInteger\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nconst RuntimeBoolean_1 = require(\"../library/RuntimeBoolean\");\r\nclass AssignVariableHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.Assign;\r\n    }\r\n    handle(thread) {\r\n        const instance = thread.currentMethod.pop();\r\n        const value = thread.currentMethod.pop();\r\n        this.logInteraction(thread, instance, value);\r\n        if (instance instanceof RuntimeString_1.RuntimeString) {\r\n            instance.value = value.value;\r\n        }\r\n        else if (instance instanceof RuntimeInteger_1.RuntimeInteger) {\r\n            instance.value = value.value;\r\n        }\r\n        else if (instance instanceof RuntimeBoolean_1.RuntimeBoolean) {\r\n            instance.value = value.value;\r\n        }\r\n        else {\r\n            throw new RuntimeError_1.RuntimeError(\"Encountered unsupported type on the stack\");\r\n        }\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.AssignVariableHandler = AssignVariableHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/AssignVariableHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BranchRelativeHandler = void 0;\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nclass BranchRelativeHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.BranchRelative;\r\n    }\r\n    handle(thread) {\r\n        var _a;\r\n        const relativeAmount = (_a = thread.currentInstruction) === null || _a === void 0 ? void 0 : _a.value;\r\n        this.logInteraction(thread, relativeAmount);\r\n        thread.jumpToLine(thread.currentMethod.stackFrame.currentInstruction + relativeAmount);\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.BranchRelativeHandler = BranchRelativeHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/BranchRelativeHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BranchRelativeIfFalseHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass BranchRelativeIfFalseHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.BranchRelativeIfFalse;\r\n    }\r\n    handle(thread) {\r\n        var _a;\r\n        const relativeAmount = (_a = thread.currentInstruction) === null || _a === void 0 ? void 0 : _a.value;\r\n        const value = thread.currentMethod.pop();\r\n        this.logInteraction(thread, relativeAmount, '//', value);\r\n        if (!value.value) {\r\n            thread.jumpToLine(thread.currentMethod.stackFrame.currentInstruction + relativeAmount);\r\n        }\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.BranchRelativeIfFalseHandler = BranchRelativeIfFalseHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/BranchRelativeIfFalseHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CompareLessThanHandler = void 0;\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nconst Memory_1 = require(\"../common/Memory\");\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nclass CompareLessThanHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.CompareLessThan;\r\n    }\r\n    handle(thread) {\r\n        this.logInteraction(thread);\r\n        const firstValue = thread.currentMethod.pop();\r\n        const secondValue = thread.currentMethod.pop();\r\n        const isLessThan = Memory_1.Memory.allocateBoolean(firstValue.value < secondValue.value);\r\n        thread.currentMethod.push(isLessThan);\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.CompareLessThanHandler = CompareLessThanHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/CompareLessThanHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ComparisonHandler = void 0;\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nconst Memory_1 = require(\"../common/Memory\");\r\nconst RuntimeError_1 = require(\"../errors/RuntimeError\");\r\nconst RuntimeBoolean_1 = require(\"../library/RuntimeBoolean\");\r\nconst RuntimeInteger_1 = require(\"../library/RuntimeInteger\");\r\nconst RuntimeString_1 = require(\"../library/RuntimeString\");\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nclass ComparisonHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.CompareEqual;\r\n    }\r\n    handle(thread) {\r\n        var instance = thread.currentMethod.pop();\r\n        var comparand = thread.currentMethod.pop();\r\n        this.logInteraction(thread, instance, comparand);\r\n        if (instance instanceof RuntimeString_1.RuntimeString && comparand instanceof RuntimeString_1.RuntimeString) {\r\n            var value = Memory_1.Memory.allocateBoolean(instance.value == comparand.value);\r\n            thread.currentMethod.push(value);\r\n        }\r\n        else if (instance instanceof RuntimeInteger_1.RuntimeInteger && comparand instanceof RuntimeInteger_1.RuntimeInteger) {\r\n            var value = Memory_1.Memory.allocateBoolean(instance.value == comparand.value);\r\n            thread.currentMethod.push(value);\r\n        }\r\n        else if (instance instanceof RuntimeBoolean_1.RuntimeBoolean && comparand instanceof RuntimeBoolean_1.RuntimeBoolean) {\r\n            var value = Memory_1.Memory.allocateBoolean(instance.value === comparand.value);\r\n            thread.currentMethod.push(value);\r\n        }\r\n        else {\r\n            throw new RuntimeError_1.RuntimeError(`Encountered type mismatch on stack during comparison: ${instance === null || instance === void 0 ? void 0 : instance.typeName} == ${comparand === null || comparand === void 0 ? void 0 : comparand.typeName}`);\r\n        }\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.ComparisonHandler = ComparisonHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/ComparisonHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ConcatenateHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst Memory_1 = require(\"../common/Memory\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass ConcatenateHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.Concatenate;\r\n    }\r\n    handle(thread) {\r\n        const last = thread.currentMethod.pop();\r\n        const first = thread.currentMethod.pop();\r\n        this.logInteraction(thread, first.value, last.value);\r\n        const concatenated = Memory_1.Memory.allocateString(first.value + \" \" + last.value);\r\n        thread.currentMethod.push(concatenated);\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.ConcatenateHandler = ConcatenateHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/ConcatenateHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CreateDelegateHandler = void 0;\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nconst Memory_1 = require(\"../common/Memory\");\r\nconst RuntimeDelegate_1 = require(\"../library/RuntimeDelegate\");\r\nconst Variable_1 = require(\"../library/Variable\");\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nclass CreateDelegateHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.CreateDelegate;\r\n    }\r\n    handle(thread) {\r\n        const typeAndMethod = thread.currentInstructionValueAs();\r\n        const implicitThis = thread.currentMethod.pop();\r\n        this.logInteraction(thread, typeAndMethod);\r\n        const parts = typeAndMethod.split(':');\r\n        const typeName = parts[0];\r\n        const methodName = parts[1];\r\n        const type = Memory_1.Memory.findTypeByName(typeName);\r\n        const method = type.methods.find(method => method.name == methodName);\r\n        method.actualParameters.push(Variable_1.Variable.forThis(type, implicitThis));\r\n        const delegate = new RuntimeDelegate_1.RuntimeDelegate(method);\r\n        thread.currentMethod.push(delegate);\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.CreateDelegateHandler = CreateDelegateHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/CreateDelegateHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ExternalCallHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass ExternalCallHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.ExternalCall;\r\n    }\r\n    handle(thread) {\r\n        var _a;\r\n        const methodName = (_a = thread.currentInstruction) === null || _a === void 0 ? void 0 : _a.value;\r\n        const instance = thread.currentMethod.pop();\r\n        const method = this.locateFunction(instance, methodName);\r\n        this.logInteraction(thread, `${instance === null || instance === void 0 ? void 0 : instance.typeName}::${methodName}(...${method.length})`);\r\n        const args = [];\r\n        for (let i = 0; i < method.length; i++) {\r\n            args.push(thread.currentMethod.pop());\r\n        }\r\n        const result = method.call(instance, ...args);\r\n        if (result) {\r\n            thread.currentMethod.push(result);\r\n        }\r\n        return super.handle(thread);\r\n    }\r\n    locateFunction(instance, methodName) {\r\n        return instance[methodName];\r\n    }\r\n}\r\nexports.ExternalCallHandler = ExternalCallHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/ExternalCallHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GoToHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst RuntimeError_1 = require(\"../errors/RuntimeError\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass GoToHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.GoTo;\r\n    }\r\n    handle(thread) {\r\n        var _a;\r\n        const instructionNumber = (_a = thread.currentInstruction) === null || _a === void 0 ? void 0 : _a.value;\r\n        this.logInteraction(thread, instructionNumber);\r\n        if (typeof instructionNumber === \"number\") {\r\n            // We need to jump one previous to the desired instruction because after \r\n            // evaluating this goto we'll move forward (which will move to the desired one).\r\n            thread.jumpToLine(instructionNumber - 1);\r\n        }\r\n        else {\r\n            throw new RuntimeError_1.RuntimeError(\"Unable to goto\");\r\n        }\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.GoToHandler = GoToHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/GoToHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HandleCommandHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst RuntimeCommand_1 = require(\"../library/RuntimeCommand\");\r\nconst RuntimeError_1 = require(\"../errors/RuntimeError\");\r\nconst Understanding_1 = require(\"../../library/Understanding\");\r\nconst Meaning_1 = require(\"../library/Meaning\");\r\nconst RuntimeWorldObject_1 = require(\"../library/RuntimeWorldObject\");\r\nconst WorldObject_1 = require(\"../../library/WorldObject\");\r\nconst Memory_1 = require(\"../common/Memory\");\r\nconst Type_1 = require(\"../../common/Type\");\r\nconst Player_1 = require(\"../../library/Player\");\r\nconst EventType_1 = require(\"../../common/EventType\");\r\nconst RuntimeDelegate_1 = require(\"../library/RuntimeDelegate\");\r\nconst Variable_1 = require(\"../library/Variable\");\r\nconst RuntimeItem_1 = require(\"../library/RuntimeItem\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass HandleCommandHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor(output) {\r\n        super();\r\n        this.output = output;\r\n        this.code = OpCode_1.OpCode.HandleCommand;\r\n    }\r\n    handle(thread) {\r\n        const command = thread.currentMethod.pop();\r\n        if (!(command instanceof RuntimeCommand_1.RuntimeCommand)) {\r\n            throw new RuntimeError_1.RuntimeError(`Unable to handle a non-command, found '${command}`);\r\n        }\r\n        const action = command.action.value;\r\n        const targetName = command.targetName.value;\r\n        this.logInteraction(thread, `'${action} ${targetName}'`);\r\n        const understandingsByAction = new Map(thread.knownUnderstandings.map(x => { var _a; return [(_a = x.fields.find(field => field.name == Understanding_1.Understanding.action)) === null || _a === void 0 ? void 0 : _a.defaultValue, x]; }));\r\n        const understanding = understandingsByAction.get(action);\r\n        if (!understanding) {\r\n            this.output.write(\"I don't know how to do that.\");\r\n            return super.handle(thread);\r\n        }\r\n        const meaningField = understanding.fields.find(x => x.name == Understanding_1.Understanding.meaning);\r\n        const meaning = this.determineMeaningFor(meaningField === null || meaningField === void 0 ? void 0 : meaningField.defaultValue);\r\n        const actualTarget = this.inferTargetFrom(thread, targetName, meaning);\r\n        if (!actualTarget) {\r\n            this.output.write(\"I don't know what you're referring to.\");\r\n            return super.handle(thread);\r\n        }\r\n        switch (meaning) {\r\n            case Meaning_1.Meaning.Describing: {\r\n                this.describe(thread, actualTarget, false);\r\n                break;\r\n            }\r\n            case Meaning_1.Meaning.Moving: {\r\n                const nextPlace = actualTarget;\r\n                const currentPlace = thread.currentPlace;\r\n                thread.currentPlace = nextPlace;\r\n                this.describe(thread, actualTarget, false);\r\n                this.raiseEvent(thread, nextPlace, EventType_1.EventType.PlayerEntersPlace);\r\n                this.raiseEvent(thread, currentPlace, EventType_1.EventType.PlayerExitsPlace);\r\n                break;\r\n            }\r\n            case Meaning_1.Meaning.Taking: {\r\n                if (!(actualTarget instanceof RuntimeItem_1.RuntimeItem)) {\r\n                    this.output.write(\"I can't take that.\");\r\n                    return super.handle(thread);\r\n                }\r\n                const list = thread.currentPlace.getContentsField();\r\n                list.items = list.items.filter(x => x.typeName.toLowerCase() !== targetName.toLowerCase());\r\n                const inventory = thread.currentPlayer.getContentsField();\r\n                inventory.items.push(actualTarget);\r\n                this.describe(thread, thread.currentPlace, false);\r\n                break;\r\n            }\r\n            case Meaning_1.Meaning.Inventory: {\r\n                const inventory = actualTarget.getContentsField();\r\n                this.nameAndTotalContents(thread, inventory);\r\n                break;\r\n            }\r\n            case Meaning_1.Meaning.Dropping: {\r\n                const list = thread.currentPlayer.getContentsField();\r\n                list.items = list.items.filter(x => x.typeName.toLowerCase() !== targetName.toLowerCase());\r\n                const contents = thread.currentPlace.getContentsField();\r\n                contents.items.push(actualTarget);\r\n                this.describe(thread, thread.currentPlace, false);\r\n                break;\r\n            }\r\n            default:\r\n                throw new RuntimeError_1.RuntimeError(\"Unsupported meaning found\");\r\n        }\r\n        return super.handle(thread);\r\n    }\r\n    raiseEvent(thread, location, type) {\r\n        const events = Array.from(location.methods.values()).filter(x => x.eventType == type);\r\n        for (const event of events) {\r\n            const method = location.methods.get(event.name);\r\n            method.actualParameters = [Variable_1.Variable.forThis(new Type_1.Type(location === null || location === void 0 ? void 0 : location.typeName, location === null || location === void 0 ? void 0 : location.parentTypeName), location)];\r\n            const delegate = new RuntimeDelegate_1.RuntimeDelegate(method);\r\n            thread.currentMethod.push(delegate);\r\n        }\r\n    }\r\n    inferTargetFrom(thread, targetName, meaning) {\r\n        var _a, _b, _c, _d;\r\n        const lookupInstance = (name) => {\r\n            try {\r\n                return Memory_1.Memory.findInstanceByName(name);\r\n            }\r\n            catch (ex) {\r\n                return undefined;\r\n            }\r\n        };\r\n        if (meaning === Meaning_1.Meaning.Moving) {\r\n            const placeName = (_b = (_a = thread.currentPlace) === null || _a === void 0 ? void 0 : _a.fields.get(`~${targetName}`)) === null || _b === void 0 ? void 0 : _b.value;\r\n            if (!placeName) {\r\n                return undefined;\r\n            }\r\n            return lookupInstance(placeName.value);\r\n        }\r\n        else if (meaning === Meaning_1.Meaning.Inventory) {\r\n            return lookupInstance(Player_1.Player.typeName);\r\n        }\r\n        else if (meaning === Meaning_1.Meaning.Describing) {\r\n            if (!targetName) {\r\n                return thread.currentPlace;\r\n            }\r\n            const placeContents = (_c = thread.currentPlace) === null || _c === void 0 ? void 0 : _c.getContentsField();\r\n            const itemOrDecoration = placeContents.items.find(x => x.typeName.toLowerCase() === targetName.toLowerCase());\r\n            if (itemOrDecoration instanceof RuntimeWorldObject_1.RuntimeWorldObject) {\r\n                return itemOrDecoration;\r\n            }\r\n            return lookupInstance((_d = thread.currentPlace) === null || _d === void 0 ? void 0 : _d.typeName);\r\n        }\r\n        else if (meaning === Meaning_1.Meaning.Taking) {\r\n            const list = thread.currentPlace.getContentsField();\r\n            const matchingItems = list.items.filter(x => x.typeName.toLowerCase() === targetName.toLowerCase());\r\n            if (matchingItems.length == 0) {\r\n                return undefined;\r\n            }\r\n            return matchingItems[0];\r\n        }\r\n        else if (meaning === Meaning_1.Meaning.Dropping) {\r\n            const list = thread.currentPlayer.getContentsField();\r\n            const matchingItems = list.items.filter(x => x.typeName.toLowerCase() === targetName.toLowerCase());\r\n            if (matchingItems.length == 0) {\r\n                return undefined;\r\n            }\r\n            return matchingItems[0];\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n    nameAndTotalContents(thread, contents) {\r\n        const names = contents.items.map(x => x.typeName);\r\n        const namesWithCount = new Map();\r\n        for (const name of names) {\r\n            if (!namesWithCount.has(name)) {\r\n                namesWithCount.set(name, 1);\r\n            }\r\n            else {\r\n                const count = namesWithCount.get(name);\r\n                namesWithCount.set(name, count + 1);\r\n            }\r\n        }\r\n        const namedValues = [];\r\n        for (const [name, value] of namesWithCount) {\r\n            namedValues.push(`${value} ${name}(s)`);\r\n        }\r\n        namedValues.forEach(x => this.output.write(x));\r\n    }\r\n    describe(thread, target, isShallowDescription) {\r\n        if (!isShallowDescription) {\r\n            const contents = target.getFieldAsList(WorldObject_1.WorldObject.contents);\r\n            this.describeContents(thread, contents);\r\n        }\r\n        const describe = target.methods.get(WorldObject_1.WorldObject.describe);\r\n        describe.actualParameters.unshift(Variable_1.Variable.forThis(new Type_1.Type(target === null || target === void 0 ? void 0 : target.typeName, target === null || target === void 0 ? void 0 : target.parentTypeName), target));\r\n        thread.currentMethod.push(new RuntimeDelegate_1.RuntimeDelegate(describe));\r\n    }\r\n    observe(thread, target) {\r\n        const observe = target.methods.get(WorldObject_1.WorldObject.observe);\r\n        observe.actualParameters.unshift(Variable_1.Variable.forThis(new Type_1.Type(target === null || target === void 0 ? void 0 : target.typeName, target === null || target === void 0 ? void 0 : target.parentTypeName), target));\r\n        thread.currentMethod.push(new RuntimeDelegate_1.RuntimeDelegate(observe));\r\n    }\r\n    describeContents(thread, target) {\r\n        for (const item of target.items) {\r\n            this.observe(thread, item);\r\n        }\r\n    }\r\n    determineMeaningFor(action) {\r\n        const systemAction = `~${action}`;\r\n        // TODO: Support custom actions better.\r\n        switch (systemAction) {\r\n            case Understanding_1.Understanding.describing: return Meaning_1.Meaning.Describing;\r\n            case Understanding_1.Understanding.moving: return Meaning_1.Meaning.Moving;\r\n            case Understanding_1.Understanding.direction: return Meaning_1.Meaning.Direction;\r\n            case Understanding_1.Understanding.taking: return Meaning_1.Meaning.Taking;\r\n            case Understanding_1.Understanding.inventory: return Meaning_1.Meaning.Inventory;\r\n            case Understanding_1.Understanding.dropping: return Meaning_1.Meaning.Dropping;\r\n            default:\r\n                return Meaning_1.Meaning.Custom;\r\n        }\r\n    }\r\n}\r\nexports.HandleCommandHandler = HandleCommandHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/HandleCommandHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.InstanceCallHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst Variable_1 = require(\"../library/Variable\");\r\nconst Type_1 = require(\"../../common/Type\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass InstanceCallHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor(methodName) {\r\n        super();\r\n        this.methodName = methodName;\r\n        this.code = OpCode_1.OpCode.InstanceCall;\r\n    }\r\n    handle(thread) {\r\n        var _a;\r\n        const current = thread.currentMethod;\r\n        if (!this.methodName) {\r\n            this.methodName = (_a = thread.currentInstruction) === null || _a === void 0 ? void 0 : _a.value;\r\n        }\r\n        try {\r\n            const instance = current.pop();\r\n            const method = instance === null || instance === void 0 ? void 0 : instance.methods.get(this.methodName);\r\n            this.logInteraction(thread, `${instance === null || instance === void 0 ? void 0 : instance.typeName}::${this.methodName}(...${method.parameters.length})`);\r\n            const parameterValues = [];\r\n            for (let i = 0; i < method.parameters.length; i++) {\r\n                const parameter = method.parameters[i];\r\n                const instance = current.pop();\r\n                const variable = new Variable_1.Variable(parameter.name, parameter.type, instance);\r\n                parameterValues.push(variable);\r\n            }\r\n            // HACK: We shouldn't create our own type, we should inherently know what it is.\r\n            parameterValues.unshift(Variable_1.Variable.forThis(new Type_1.Type(instance === null || instance === void 0 ? void 0 : instance.typeName, instance === null || instance === void 0 ? void 0 : instance.parentTypeName), instance));\r\n            method.actualParameters = parameterValues;\r\n            thread.activateMethod(method);\r\n        }\r\n        finally {\r\n            this.methodName = undefined;\r\n        }\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.InstanceCallHandler = InstanceCallHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/InstanceCallHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.InvokeDelegateHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst RuntimeDelegate_1 = require(\"../library/RuntimeDelegate\");\r\nconst RuntimeError_1 = require(\"../errors/RuntimeError\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass InvokeDelegateHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.InvokeDelegate;\r\n    }\r\n    handle(thread) {\r\n        this.logInteraction(thread);\r\n        const delegate = thread.currentMethod.pop();\r\n        if (delegate instanceof RuntimeDelegate_1.RuntimeDelegate) {\r\n            const activation = thread.activateMethod(delegate.wrappedMethod);\r\n        }\r\n        else {\r\n            throw new RuntimeError_1.RuntimeError(`Unable to invoke delegate for non-delegate instance '${delegate}'`);\r\n        }\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.InvokeDelegateHandler = InvokeDelegateHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/InvokeDelegateHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.InvokeDelegateOnInstanceHandler = void 0;\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nconst Memory_1 = require(\"../common/Memory\");\r\nconst RuntimeError_1 = require(\"../errors/RuntimeError\");\r\nconst RuntimeDelegate_1 = require(\"../library/RuntimeDelegate\");\r\nconst Variable_1 = require(\"../library/Variable\");\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nclass InvokeDelegateOnInstanceHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.InvokeDelegateOnInstance;\r\n    }\r\n    handle(thread) {\r\n        const delegate = thread.currentMethod.pop();\r\n        const instance = thread.currentMethod.pop();\r\n        this.logInteraction(thread, `~anon(${instance.typeName})`);\r\n        if (delegate instanceof RuntimeDelegate_1.RuntimeDelegate) {\r\n            const type = Memory_1.Memory.findTypeByName(instance.typeName);\r\n            const actualParametersWithoutThis = delegate.wrappedMethod.actualParameters.filter(x => x.name != \"~this\");\r\n            actualParametersWithoutThis.push(Variable_1.Variable.forThis(type, instance));\r\n            delegate.wrappedMethod.actualParameters = actualParametersWithoutThis;\r\n            const activation = thread.activateMethod(delegate.wrappedMethod);\r\n        }\r\n        else {\r\n            throw new RuntimeError_1.RuntimeError(`Unable to invoke delegate for non-delegate instance '${delegate}'`);\r\n        }\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.InvokeDelegateOnInstanceHandler = InvokeDelegateOnInstanceHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/InvokeDelegateOnInstanceHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LoadBooleanHandler = void 0;\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nconst Memory_1 = require(\"../common/Memory\");\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nclass LoadBooleanHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.LoadBoolean;\r\n    }\r\n    handle(thread) {\r\n        var _a;\r\n        const value = (_a = thread.currentInstruction) === null || _a === void 0 ? void 0 : _a.value;\r\n        const runtimeValue = Memory_1.Memory.allocateBoolean(value);\r\n        thread.currentMethod.push(runtimeValue);\r\n        this.logInteraction(thread, value);\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.LoadBooleanHandler = LoadBooleanHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/LoadBooleanHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LoadElementHandler = void 0;\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nclass LoadElementHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.LoadElement;\r\n    }\r\n    handle(thread) {\r\n        this.logInteraction(thread);\r\n        const elementNumber = thread.currentMethod.pop();\r\n        const list = thread.currentMethod.pop();\r\n        const item = list.items[elementNumber.value];\r\n        thread.currentMethod.push(item);\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.LoadElementHandler = LoadElementHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/LoadElementHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LoadEmptyHandler = void 0;\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nconst RuntimeEmpty_1 = require(\"../library/RuntimeEmpty\");\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nclass LoadEmptyHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.LoadEmpty;\r\n    }\r\n    handle(thread) {\r\n        this.logInteraction(thread);\r\n        thread.currentMethod.push(new RuntimeEmpty_1.RuntimeEmpty());\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.LoadEmptyHandler = LoadEmptyHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/LoadEmptyHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LoadFieldHandler = void 0;\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nclass LoadFieldHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.LoadField;\r\n    }\r\n    handle(thread) {\r\n        const instance = thread.currentMethod.pop();\r\n        const fieldName = thread.currentInstructionValueAs();\r\n        const field = instance === null || instance === void 0 ? void 0 : instance.fields.get(fieldName);\r\n        const value = field === null || field === void 0 ? void 0 : field.value;\r\n        this.logInteraction(thread, `${instance === null || instance === void 0 ? void 0 : instance.typeName}::${fieldName}:${field === null || field === void 0 ? void 0 : field.type.name}`, '//', typeof value, value);\r\n        thread.currentMethod.push(value);\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.LoadFieldHandler = LoadFieldHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/LoadFieldHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LoadInstanceHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst RuntimeError_1 = require(\"../errors/RuntimeError\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass LoadInstanceHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.LoadInstance;\r\n    }\r\n    handle(thread) {\r\n        var _a;\r\n        const typeName = (_a = thread.currentInstruction) === null || _a === void 0 ? void 0 : _a.value;\r\n        this.logInteraction(thread, typeName);\r\n        if (typeName === \"~it\") {\r\n            const subject = thread.currentPlace;\r\n            thread.currentMethod.push(subject);\r\n        }\r\n        else {\r\n            throw new RuntimeError_1.RuntimeError(`Unable to load instance for unsupported type '${typeName}'`);\r\n        }\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.LoadInstanceHandler = LoadInstanceHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/LoadInstanceHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LoadLocalHandler = void 0;\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nclass LoadLocalHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.LoadLocal;\r\n    }\r\n    handle(thread) {\r\n        var _a, _b;\r\n        const localName = (_a = thread.currentInstruction) === null || _a === void 0 ? void 0 : _a.value;\r\n        const parameter = (_b = thread.currentMethod.method) === null || _b === void 0 ? void 0 : _b.actualParameters.find(x => x.name == localName);\r\n        thread.currentMethod.push(parameter === null || parameter === void 0 ? void 0 : parameter.value);\r\n        this.logInteraction(thread, localName, '//', parameter === null || parameter === void 0 ? void 0 : parameter.value);\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.LoadLocalHandler = LoadLocalHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/LoadLocalHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LoadNumberHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst Memory_1 = require(\"../common/Memory\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass LoadNumberHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.LoadNumber;\r\n    }\r\n    handle(thread) {\r\n        var _a;\r\n        const value = (_a = thread.currentInstruction) === null || _a === void 0 ? void 0 : _a.value;\r\n        const runtimeValue = Memory_1.Memory.allocateNumber(value);\r\n        thread.currentMethod.push(runtimeValue);\r\n        this.logInteraction(thread, value);\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.LoadNumberHandler = LoadNumberHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/LoadNumberHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LoadPropertyHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst InstanceCallHandler_1 = require(\"./InstanceCallHandler\");\r\nconst LoadThisHandler_1 = require(\"./LoadThisHandler\");\r\nconst EvaluationResult_1 = require(\"../EvaluationResult\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass LoadPropertyHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor(fieldName) {\r\n        super();\r\n        this.fieldName = fieldName;\r\n        this.code = OpCode_1.OpCode.LoadProperty;\r\n    }\r\n    handle(thread) {\r\n        var _a;\r\n        const instance = thread.currentMethod.pop();\r\n        if (!this.fieldName) {\r\n            this.fieldName = (_a = thread.currentInstruction) === null || _a === void 0 ? void 0 : _a.value;\r\n        }\r\n        try {\r\n            const field = instance === null || instance === void 0 ? void 0 : instance.fields.get(this.fieldName);\r\n            const value = field === null || field === void 0 ? void 0 : field.value;\r\n            const getField = instance === null || instance === void 0 ? void 0 : instance.methods.get(`~get_${this.fieldName}`);\r\n            this.logInteraction(thread, `${instance === null || instance === void 0 ? void 0 : instance.typeName}::${this.fieldName}`, `{get=${getField != undefined}}`, '//', value);\r\n            if (getField) {\r\n                thread.currentMethod.push(value);\r\n                const loadThis = new LoadThisHandler_1.LoadThisHandler();\r\n                const result = loadThis.handle(thread);\r\n                if (result != EvaluationResult_1.EvaluationResult.Continue) {\r\n                    return result;\r\n                }\r\n                const handler = new InstanceCallHandler_1.InstanceCallHandler(getField.name);\r\n                handler.handle(thread);\r\n                //getField.actualParameters.push(new Variable(\"~value\", field?.type!, value));\r\n                //thread.activateMethod(getField);\r\n            }\r\n            else {\r\n                thread.currentMethod.push(value);\r\n            }\r\n            return super.handle(thread);\r\n        }\r\n        finally {\r\n            this.fieldName = undefined;\r\n        }\r\n    }\r\n}\r\nexports.LoadPropertyHandler = LoadPropertyHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/LoadPropertyHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LoadStringHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst RuntimeString_1 = require(\"../library/RuntimeString\");\r\nconst RuntimeError_1 = require(\"../errors/RuntimeError\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass LoadStringHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.LoadString;\r\n    }\r\n    handle(thread) {\r\n        const value = thread.currentInstruction.value;\r\n        this.logInteraction(thread, value);\r\n        if (typeof value === \"string\") {\r\n            const stringValue = new RuntimeString_1.RuntimeString(value);\r\n            thread.currentMethod.push(stringValue);\r\n        }\r\n        else {\r\n            throw new RuntimeError_1.RuntimeError(\"Expected a string\");\r\n        }\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.LoadStringHandler = LoadStringHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/LoadStringHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LoadThisHandler = void 0;\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nclass LoadThisHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.LoadThis;\r\n    }\r\n    handle(thread) {\r\n        var _a;\r\n        const instance = (_a = thread.currentMethod.method) === null || _a === void 0 ? void 0 : _a.actualParameters[0].value;\r\n        thread.currentMethod.push(instance);\r\n        this.logInteraction(thread);\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.LoadThisHandler = LoadThisHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/LoadThisHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NewInstanceHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst RuntimeError_1 = require(\"../errors/RuntimeError\");\r\nconst Memory_1 = require(\"../common/Memory\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass NewInstanceHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.NewInstance;\r\n    }\r\n    handle(thread) {\r\n        var _a;\r\n        const typeName = (_a = thread.currentInstruction) === null || _a === void 0 ? void 0 : _a.value;\r\n        this.logInteraction(thread, typeName);\r\n        if (typeof typeName === \"string\") {\r\n            const type = thread.knownTypes.get(typeName);\r\n            if (!type) {\r\n                throw new RuntimeError_1.RuntimeError(\"Unable to locate type\");\r\n            }\r\n            const instance = Memory_1.Memory.allocate(type);\r\n            thread.currentMethod.push(instance);\r\n        }\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.NewInstanceHandler = NewInstanceHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/NewInstanceHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NoOpHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass NoOpHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.NoOp;\r\n    }\r\n    handle(thread) {\r\n        this.logInteraction(thread);\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.NoOpHandler = NoOpHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/NoOpHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ParseCommandHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst RuntimeString_1 = require(\"../library/RuntimeString\");\r\nconst RuntimeError_1 = require(\"../errors/RuntimeError\");\r\nconst Memory_1 = require(\"../common/Memory\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass ParseCommandHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.ParseCommand;\r\n    }\r\n    handle(thread) {\r\n        this.logInteraction(thread);\r\n        const text = thread.currentMethod.pop();\r\n        if (text instanceof RuntimeString_1.RuntimeString) {\r\n            const commandText = text.value;\r\n            const command = this.parseCommand(commandText);\r\n            thread.currentMethod.push(command);\r\n        }\r\n        else {\r\n            throw new RuntimeError_1.RuntimeError(\"Unable to parse command\");\r\n        }\r\n        return super.handle(thread);\r\n    }\r\n    parseCommand(text) {\r\n        const pieces = text.split(\" \");\r\n        const command = Memory_1.Memory.allocateCommand();\r\n        command.action = Memory_1.Memory.allocateString(pieces[0]);\r\n        command.targetName = Memory_1.Memory.allocateString(pieces[1]);\r\n        return command;\r\n    }\r\n}\r\nexports.ParseCommandHandler = ParseCommandHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/ParseCommandHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PrintHandler = void 0;\r\nconst RuntimeString_1 = require(\"../library/RuntimeString\");\r\nconst RuntimeError_1 = require(\"../errors/RuntimeError\");\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass PrintHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor(output) {\r\n        super();\r\n        this.code = OpCode_1.OpCode.Print;\r\n        this.output = output;\r\n    }\r\n    handle(thread) {\r\n        const text = thread.currentMethod.pop();\r\n        this.logInteraction(thread);\r\n        if (text instanceof RuntimeString_1.RuntimeString) {\r\n            this.output.write(text.value);\r\n        }\r\n        else {\r\n            throw new RuntimeError_1.RuntimeError(\"Unable to print, encountered a type on the stack other than string\");\r\n        }\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.PrintHandler = PrintHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/PrintHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ReadInputHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst EvaluationResult_1 = require(\"../EvaluationResult\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass ReadInputHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.ReadInput;\r\n    }\r\n    handle(thread) {\r\n        this.logInteraction(thread);\r\n        return EvaluationResult_1.EvaluationResult.SuspendForInput;\r\n    }\r\n}\r\nexports.ReadInputHandler = ReadInputHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/ReadInputHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ReturnHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst EvaluationResult_1 = require(\"../EvaluationResult\");\r\nconst RuntimeEmpty_1 = require(\"../library/RuntimeEmpty\");\r\nconst RuntimeError_1 = require(\"../errors/RuntimeError\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass ReturnHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.Return;\r\n    }\r\n    handle(thread) {\r\n        // TODO: Handle returning top value on stack based on return type of method.\r\n        var _a, _b, _c;\r\n        const current = thread.currentMethod;\r\n        const size = current.stackSize();\r\n        const hasReturnType = ((_a = current.method) === null || _a === void 0 ? void 0 : _a.returnType) != \"\";\r\n        if (hasReturnType) {\r\n            if (size == 0) {\r\n                throw new RuntimeError_1.RuntimeError(\"Expected return value from method but found no instance on the stack\");\r\n            }\r\n            else if (size > 1) {\r\n                throw new RuntimeError_1.RuntimeError(`Stack Imbalance! Returning from '${(_b = current.method) === null || _b === void 0 ? void 0 : _b.name}' found '${size}' instances left but expected one.`);\r\n            }\r\n        }\r\n        else {\r\n            if (size > 0) {\r\n                throw new RuntimeError_1.RuntimeError(`Stack Imbalance! Returning from '${(_c = current.method) === null || _c === void 0 ? void 0 : _c.name}' found '${size}' instances left but expected zero.`);\r\n            }\r\n        }\r\n        const returnValue = thread.returnFromCurrentMethod();\r\n        if (!(returnValue instanceof RuntimeEmpty_1.RuntimeEmpty)) {\r\n            this.logInteraction(thread, returnValue);\r\n            thread === null || thread === void 0 ? void 0 : thread.currentMethod.push(returnValue);\r\n        }\r\n        else {\r\n            this.logInteraction(thread, 'void');\r\n        }\r\n        return EvaluationResult_1.EvaluationResult.Continue;\r\n    }\r\n}\r\nexports.ReturnHandler = ReturnHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/ReturnHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SetLocalHandler = void 0;\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nconst Type_1 = require(\"../../common/Type\");\r\nconst RuntimeAny_1 = require(\"../library/RuntimeAny\");\r\nconst Variable_1 = require(\"../library/Variable\");\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nclass SetLocalHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.SetLocal;\r\n    }\r\n    handle(thread) {\r\n        var _a, _b, _c;\r\n        const localName = (_a = thread.currentInstruction) === null || _a === void 0 ? void 0 : _a.value;\r\n        const value = thread.currentMethod.pop();\r\n        this.logInteraction(thread, localName);\r\n        let parameter = (_b = thread.currentMethod.method) === null || _b === void 0 ? void 0 : _b.actualParameters.find(x => x.name == localName);\r\n        if (!parameter) {\r\n            parameter = new Variable_1.Variable(localName, new Type_1.Type(RuntimeAny_1.RuntimeAny.name, \"\"), undefined);\r\n            (_c = thread.currentMethod.method) === null || _c === void 0 ? void 0 : _c.actualParameters.push(parameter);\r\n        }\r\n        parameter.value = value;\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.SetLocalHandler = SetLocalHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/SetLocalHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.StaticCallHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass StaticCallHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.StaticCall;\r\n    }\r\n    handle(thread) {\r\n        var _a;\r\n        const callText = (_a = thread.currentInstruction) === null || _a === void 0 ? void 0 : _a.value;\r\n        const pieces = callText.split(\".\");\r\n        const typeName = pieces[0];\r\n        const methodName = pieces[1];\r\n        const type = thread.knownTypes.get(typeName);\r\n        const method = type === null || type === void 0 ? void 0 : type.methods.find(x => x.name === methodName);\r\n        this.logInteraction(thread, `${typeName}::${methodName}()`);\r\n        thread.activateMethod(method);\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.StaticCallHandler = StaticCallHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/StaticCallHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TypeOfHandler = void 0;\r\nconst OpCodeHandler_1 = require(\"../OpCodeHandler\");\r\nconst Memory_1 = require(\"../common/Memory\");\r\nconst OpCode_1 = require(\"../../common/OpCode\");\r\nclass TypeOfHandler extends OpCodeHandler_1.OpCodeHandler {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = OpCode_1.OpCode.TypeOf;\r\n    }\r\n    handle(thread) {\r\n        var _a;\r\n        const typeName = (_a = thread.currentInstruction) === null || _a === void 0 ? void 0 : _a.value;\r\n        this.logInteraction(thread, typeName);\r\n        if (thread.currentMethod.stackSize() == 0) {\r\n            const value = Memory_1.Memory.allocateBoolean(false);\r\n            thread.currentMethod.push(value);\r\n        }\r\n        else {\r\n            const instance = thread.currentMethod.peek();\r\n            const isType = (instance === null || instance === void 0 ? void 0 : instance.typeName) == typeName;\r\n            const result = Memory_1.Memory.allocateBoolean(isType);\r\n            thread.currentMethod.push(result);\r\n        }\r\n        return super.handle(thread);\r\n    }\r\n}\r\nexports.TypeOfHandler = TypeOfHandler;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/handlers/TypeOfHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Meaning = void 0;\r\nvar Meaning;\r\n(function (Meaning) {\r\n    Meaning[Meaning[\"Describing\"] = 0] = \"Describing\";\r\n    Meaning[Meaning[\"Taking\"] = 1] = \"Taking\";\r\n    Meaning[Meaning[\"Moving\"] = 2] = \"Moving\";\r\n    Meaning[Meaning[\"Direction\"] = 3] = \"Direction\";\r\n    Meaning[Meaning[\"Inventory\"] = 4] = \"Inventory\";\r\n    Meaning[Meaning[\"Dropping\"] = 5] = \"Dropping\";\r\n    Meaning[Meaning[\"Quitting\"] = 6] = \"Quitting\";\r\n    Meaning[Meaning[\"Custom\"] = 7] = \"Custom\";\r\n})(Meaning = exports.Meaning || (exports.Meaning = {}));\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/library/Meaning.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RuntimeAny = void 0;\r\nconst Any_1 = require(\"../../library/Any\");\r\nclass RuntimeAny {\r\n    constructor() {\r\n        this.parentTypeName = \"\";\r\n        this.typeName = Any_1.Any.typeName;\r\n        this.fields = new Map();\r\n        this.methods = new Map();\r\n    }\r\n    toString() {\r\n        return this.typeName;\r\n    }\r\n}\r\nexports.RuntimeAny = RuntimeAny;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/library/RuntimeAny.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RuntimeBoolean = void 0;\r\nconst Any_1 = require(\"../../library/Any\");\r\nconst BooleanType_1 = require(\"../../library/BooleanType\");\r\nconst RuntimeAny_1 = require(\"./RuntimeAny\");\r\nclass RuntimeBoolean extends RuntimeAny_1.RuntimeAny {\r\n    constructor(value) {\r\n        super();\r\n        this.value = value;\r\n        this.parentTypeName = Any_1.Any.typeName;\r\n        this.typeName = BooleanType_1.BooleanType.typeName;\r\n    }\r\n    toString() {\r\n        return `${this.value.toString()}:${this.typeName}`;\r\n    }\r\n}\r\nexports.RuntimeBoolean = RuntimeBoolean;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/library/RuntimeBoolean.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RuntimeCommand = void 0;\r\nconst RuntimeAny_1 = require(\"./RuntimeAny\");\r\nclass RuntimeCommand extends RuntimeAny_1.RuntimeAny {\r\n    constructor(targetName, action) {\r\n        super();\r\n        this.targetName = targetName;\r\n        this.action = action;\r\n    }\r\n}\r\nexports.RuntimeCommand = RuntimeCommand;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/library/RuntimeCommand.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RuntimeDecoration = void 0;\r\nconst RuntimeWorldObject_1 = require(\"./RuntimeWorldObject\");\r\nconst Decoration_1 = require(\"../../library/Decoration\");\r\nclass RuntimeDecoration extends RuntimeWorldObject_1.RuntimeWorldObject {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.parentTypeName = Decoration_1.Decoration.parentTypeName;\r\n        this.typeName = Decoration_1.Decoration.typeName;\r\n    }\r\n}\r\nexports.RuntimeDecoration = RuntimeDecoration;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/library/RuntimeDecoration.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RuntimeDelegate = void 0;\r\nconst RuntimeAny_1 = require(\"./RuntimeAny\");\r\nconst Any_1 = require(\"../../library/Any\");\r\nconst Delegate_1 = require(\"../../library/Delegate\");\r\nclass RuntimeDelegate extends RuntimeAny_1.RuntimeAny {\r\n    constructor(wrappedMethod) {\r\n        super();\r\n        this.wrappedMethod = wrappedMethod;\r\n        this.parentTypeName = Any_1.Any.typeName;\r\n        this.typeName = Delegate_1.Delegate.typeName;\r\n    }\r\n}\r\nexports.RuntimeDelegate = RuntimeDelegate;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/library/RuntimeDelegate.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RuntimeEmpty = void 0;\r\nconst RuntimeAny_1 = require(\"./RuntimeAny\");\r\nconst Any_1 = require(\"../../library/Any\");\r\nclass RuntimeEmpty extends RuntimeAny_1.RuntimeAny {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.parentTypeName = Any_1.Any.typeName;\r\n        this.typeName = \"~empty\";\r\n    }\r\n}\r\nexports.RuntimeEmpty = RuntimeEmpty;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/library/RuntimeEmpty.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RuntimeInteger = void 0;\r\nconst RuntimeAny_1 = require(\"./RuntimeAny\");\r\nclass RuntimeInteger extends RuntimeAny_1.RuntimeAny {\r\n    constructor(value) {\r\n        super();\r\n        this.value = value;\r\n    }\r\n    toString() {\r\n        return this.value.toString();\r\n    }\r\n}\r\nexports.RuntimeInteger = RuntimeInteger;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/library/RuntimeInteger.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RuntimeItem = void 0;\r\nconst RuntimeWorldObject_1 = require(\"./RuntimeWorldObject\");\r\nconst WorldObject_1 = require(\"../../library/WorldObject\");\r\nconst Item_1 = require(\"../../library/Item\");\r\nclass RuntimeItem extends RuntimeWorldObject_1.RuntimeWorldObject {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.parentTypeName = WorldObject_1.WorldObject.typeName;\r\n        this.typeName = Item_1.Item.typeName;\r\n    }\r\n    static get type() {\r\n        const type = RuntimeWorldObject_1.RuntimeWorldObject.type;\r\n        type.name = Item_1.Item.typeName;\r\n        return type;\r\n    }\r\n}\r\nexports.RuntimeItem = RuntimeItem;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/library/RuntimeItem.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RuntimeList = void 0;\r\nconst RuntimeAny_1 = require(\"./RuntimeAny\");\r\nconst List_1 = require(\"../../library/List\");\r\nconst Method_1 = require(\"../../common/Method\");\r\nconst Parameter_1 = require(\"../../common/Parameter\");\r\nconst NumberType_1 = require(\"../../library/NumberType\");\r\nconst StringType_1 = require(\"../../library/StringType\");\r\nconst Instruction_1 = require(\"../../common/Instruction\");\r\nconst RuntimeString_1 = require(\"./RuntimeString\");\r\nconst RuntimeInteger_1 = require(\"./RuntimeInteger\");\r\nconst Memory_1 = require(\"../common/Memory\");\r\nconst BooleanType_1 = require(\"../../library/BooleanType\");\r\nconst Any_1 = require(\"../../library/Any\");\r\nconst RuntimeDelegate_1 = require(\"./RuntimeDelegate\");\r\nconst RuntimeError_1 = require(\"../errors/RuntimeError\");\r\nclass RuntimeList extends RuntimeAny_1.RuntimeAny {\r\n    constructor(items) {\r\n        super();\r\n        this.items = items;\r\n        this.typeName = List_1.List.typeName;\r\n        this.parentTypeName = Any_1.Any.typeName;\r\n        this.defineContainsMethod();\r\n        this.defineMapMethod();\r\n        this.defineAddMethod();\r\n        this.defineCountMethod();\r\n        this.defineJoinMethod();\r\n    }\r\n    defineJoinMethod() {\r\n        const join = new Method_1.Method();\r\n        join.name = List_1.List.join;\r\n        join.parameters.push(new Parameter_1.Parameter(List_1.List.separatorParameter, RuntimeString_1.RuntimeString.name));\r\n        join.returnType = RuntimeString_1.RuntimeString.name;\r\n        join.body.push(Instruction_1.Instruction.loadLocal(List_1.List.separatorParameter), Instruction_1.Instruction.loadThis(), Instruction_1.Instruction.externalCall(\"joinList\"), Instruction_1.Instruction.return());\r\n        this.methods.set(List_1.List.join, join);\r\n    }\r\n    defineCountMethod() {\r\n        const count = new Method_1.Method();\r\n        count.name = List_1.List.count;\r\n        count.returnType = RuntimeInteger_1.RuntimeInteger.name;\r\n        count.body.push(Instruction_1.Instruction.loadThis(), Instruction_1.Instruction.externalCall(\"countItems\"), Instruction_1.Instruction.return());\r\n        this.methods.set(List_1.List.count, count);\r\n    }\r\n    defineAddMethod() {\r\n        const add = new Method_1.Method();\r\n        add.name = List_1.List.add;\r\n        add.parameters.push(new Parameter_1.Parameter(List_1.List.instanceParameter, RuntimeAny_1.RuntimeAny.name));\r\n        add.body.push(Instruction_1.Instruction.loadLocal(List_1.List.instanceParameter), Instruction_1.Instruction.loadThis(), Instruction_1.Instruction.externalCall(\"addInstance\"), Instruction_1.Instruction.return());\r\n        this.methods.set(List_1.List.add, add);\r\n    }\r\n    defineMapMethod() {\r\n        const map = new Method_1.Method();\r\n        map.name = List_1.List.map;\r\n        map.parameters.push(new Parameter_1.Parameter(List_1.List.delegateParameter, RuntimeDelegate_1.RuntimeDelegate.name));\r\n        map.returnType = this.typeName;\r\n        map.body.push(Instruction_1.Instruction.loadNumber(0), Instruction_1.Instruction.setLocal(\"~localCount\"), Instruction_1.Instruction.newInstance(this.typeName), Instruction_1.Instruction.setLocal(\"~results\"), Instruction_1.Instruction.loadLocal(\"~localCount\"), Instruction_1.Instruction.loadThis(), Instruction_1.Instruction.instanceCall(List_1.List.count), Instruction_1.Instruction.compareEqual(), Instruction_1.Instruction.branchRelativeIfFalse(2), Instruction_1.Instruction.loadLocal(\"~results\"), Instruction_1.Instruction.return(), Instruction_1.Instruction.loadThis(), Instruction_1.Instruction.loadLocal(\"~localCount\"), Instruction_1.Instruction.loadElement(), Instruction_1.Instruction.loadLocal(List_1.List.delegateParameter), Instruction_1.Instruction.invokeDelegateOnInstance(), Instruction_1.Instruction.loadLocal(\"~results\"), Instruction_1.Instruction.instanceCall(List_1.List.add), Instruction_1.Instruction.loadLocal(\"~localCount\"), Instruction_1.Instruction.loadNumber(1), Instruction_1.Instruction.add(), Instruction_1.Instruction.setLocal(\"~localCount\"), Instruction_1.Instruction.goTo(4));\r\n        this.methods.set(List_1.List.map, map);\r\n    }\r\n    defineContainsMethod() {\r\n        const contains = new Method_1.Method();\r\n        contains.name = List_1.List.contains;\r\n        contains.parameters.push(new Parameter_1.Parameter(List_1.List.typeNameParameter, StringType_1.StringType.typeName), new Parameter_1.Parameter(List_1.List.countParameter, NumberType_1.NumberType.typeName));\r\n        contains.returnType = BooleanType_1.BooleanType.typeName;\r\n        contains.body.push(Instruction_1.Instruction.loadLocal(List_1.List.countParameter), Instruction_1.Instruction.loadLocal(List_1.List.typeNameParameter), Instruction_1.Instruction.loadThis(), Instruction_1.Instruction.externalCall(\"containsType\"), Instruction_1.Instruction.return());\r\n        this.methods.set(List_1.List.contains, contains);\r\n    }\r\n    addInstance(instance) {\r\n        this.items.push(instance);\r\n    }\r\n    countItems() {\r\n        return Memory_1.Memory.allocateNumber(this.items.length);\r\n    }\r\n    containsType(typeName, count) {\r\n        const foundItems = this.items.filter(x => x.typeName === typeName.value);\r\n        const found = foundItems.length === count.value;\r\n        return Memory_1.Memory.allocateBoolean(found);\r\n    }\r\n    joinList(separator) {\r\n        if (!this.items.every(x => x instanceof RuntimeString_1.RuntimeString)) {\r\n            throw new RuntimeError_1.RuntimeError(\"Attempted to join a list with conflicting data types\");\r\n        }\r\n        const values = this.items.map(x => x.value);\r\n        if (values.length == 0 || values.every(x => x === '')) {\r\n            return Memory_1.Memory.allocateString('');\r\n        }\r\n        const joinedValue = values.join(separator.value);\r\n        return Memory_1.Memory.allocateString(joinedValue);\r\n    }\r\n}\r\nexports.RuntimeList = RuntimeList;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/library/RuntimeList.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RuntimePlace = void 0;\r\nconst RuntimeWorldObject_1 = require(\"./RuntimeWorldObject\");\r\nconst WorldObject_1 = require(\"../../library/WorldObject\");\r\nconst Place_1 = require(\"../../library/Place\");\r\nclass RuntimePlace extends RuntimeWorldObject_1.RuntimeWorldObject {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.parentTypeName = WorldObject_1.WorldObject.parentTypeName;\r\n        this.typeName = Place_1.Place.typeName;\r\n    }\r\n    static get type() {\r\n        const type = RuntimeWorldObject_1.RuntimeWorldObject.type;\r\n        type.name = Place_1.Place.typeName;\r\n        return type;\r\n    }\r\n}\r\nexports.RuntimePlace = RuntimePlace;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/library/RuntimePlace.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RuntimePlayer = void 0;\r\nconst RuntimeWorldObject_1 = require(\"./RuntimeWorldObject\");\r\nconst Player_1 = require(\"../../library/Player\");\r\nclass RuntimePlayer extends RuntimeWorldObject_1.RuntimeWorldObject {\r\n    static get type() {\r\n        const type = RuntimeWorldObject_1.RuntimeWorldObject.type;\r\n        type.name = Player_1.Player.typeName;\r\n        return type;\r\n    }\r\n}\r\nexports.RuntimePlayer = RuntimePlayer;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/library/RuntimePlayer.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RuntimeSay = void 0;\r\nconst RuntimeAny_1 = require(\"./RuntimeAny\");\r\nclass RuntimeSay extends RuntimeAny_1.RuntimeAny {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.message = \"\";\r\n    }\r\n}\r\nexports.RuntimeSay = RuntimeSay;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/library/RuntimeSay.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RuntimeString = void 0;\r\nconst RuntimeAny_1 = require(\"./RuntimeAny\");\r\nconst Any_1 = require(\"../../library/Any\");\r\nclass RuntimeString extends RuntimeAny_1.RuntimeAny {\r\n    constructor(value) {\r\n        super();\r\n        this.parentTypeName = Any_1.Any.typeName;\r\n        this.typeName = \"~string\";\r\n        this.value = value;\r\n    }\r\n    toString() {\r\n        return `\"${this.value}\"`;\r\n    }\r\n}\r\nexports.RuntimeString = RuntimeString;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/library/RuntimeString.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RuntimeWorldObject = void 0;\r\nconst RuntimeAny_1 = require(\"./RuntimeAny\");\r\nconst WorldObject_1 = require(\"../../library/WorldObject\");\r\nconst Any_1 = require(\"../../library/Any\");\r\nconst RuntimeError_1 = require(\"../errors/RuntimeError\");\r\nconst Type_1 = require(\"../../common/Type\");\r\nconst Field_1 = require(\"../../common/Field\");\r\nconst List_1 = require(\"../../library/List\");\r\nconst StringType_1 = require(\"../../library/StringType\");\r\nclass RuntimeWorldObject extends RuntimeAny_1.RuntimeAny {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.parentTypeName = Any_1.Any.typeName;\r\n        this.typeName = WorldObject_1.WorldObject.typeName;\r\n    }\r\n    static get type() {\r\n        const type = new Type_1.Type(WorldObject_1.WorldObject.typeName, WorldObject_1.WorldObject.parentTypeName);\r\n        const contents = new Field_1.Field();\r\n        contents.name = WorldObject_1.WorldObject.contents;\r\n        contents.typeName = List_1.List.typeName;\r\n        contents.defaultValue = [];\r\n        const description = new Field_1.Field();\r\n        description.name = WorldObject_1.WorldObject.description;\r\n        description.typeName = StringType_1.StringType.typeName;\r\n        description.defaultValue = \"\";\r\n        type.fields.push(contents);\r\n        type.fields.push(description);\r\n        return type;\r\n    }\r\n    getFieldValueByName(name) {\r\n        var _a;\r\n        const instance = (_a = this.fields.get(name)) === null || _a === void 0 ? void 0 : _a.value;\r\n        if (instance == undefined) {\r\n            throw new RuntimeError_1.RuntimeError(`Attempted field access for unknown field '${name}'`);\r\n        }\r\n        return instance;\r\n    }\r\n    getContentsField() {\r\n        return this.getFieldAsList(WorldObject_1.WorldObject.contents);\r\n    }\r\n    getFieldAsList(name) {\r\n        return this.getFieldValueByName(name);\r\n    }\r\n    getFieldAsString(name) {\r\n        return this.getFieldValueByName(name);\r\n    }\r\n}\r\nexports.RuntimeWorldObject = RuntimeWorldObject;\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/library/RuntimeWorldObject.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Variable = void 0;\r\nclass Variable {\r\n    constructor(name, type, value) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.value = value;\r\n    }\r\n    static forThis(type, value) {\r\n        return new Variable(Variable.thisTypeName, type, value);\r\n    }\r\n}\r\nexports.Variable = Variable;\r\nVariable.thisTypeName = \"~this\";\r\n//# sourceMappingURL=../../../../ide/js/talon/runtime/library/Variable.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst TalonIde_1 = require(\"./TalonIde\");\r\nvar ide = new TalonIde_1.TalonIde();\r\n//# sourceMappingURL=../../ide/js/talon/main.js.map"],"sourceRoot":""}